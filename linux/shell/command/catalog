#! /usr/bin/env sh  ## shebang interpreter directive; search $PATH for sh
: '\nmulti\nline\ncode\nblock\n# '  ## switchable multiline codeblock (prepend with #) / comment
:%y+  ## [vim/emacs] all lines in current buffer yank to + register (copy all to clipboard)
< $file  ## less $file (via READNULLCMD)
< ${$(get_newest_file $XDG_LOGS_HOME/upgrader/$HOST/package_lists/)%?}Q  ## make last character of newest file a Q and print that file (latest upgrade)
< $XDG_CONFIG_HOME/qutebrowser/bookmark_urls | fzf | slicer '(' ')'  ## get url from bookmark_urls
echo hello 1> $file  ## stdout redirect to $file
echo hello 2>> $file   ## stderr redirect append to $file
echo hello > /dev/null 2>&1  ## stdout redirect devnull; stderr redirect to stdout; silent execution
echo hello &> /dev/null  ## stdout redirect devnull; stderr redirect to stdout; silent execution (shorthand notation)
echo hello 2>&1 | tee -a $logfile  ## stderr redirect to stdout; append both to $logfile
echo hello &| tee -a $logfile  ## stderr redirect to stdout; append both to $logfile (shorthand notation)
((i++))  ## increase i by one (i.e. in a loop)
((i--))  ## decrease i by one (i.e. in a loop)
alacritty msg config font.size=18  ## current alacritty instance font size 18 (for screencasting)
amixer info  ## info about alsamixer device
amixer scontrols  ## list of alsamixer controls
amixer set Capture toggle  ## alsamixer toggle mic
amixer set Capture volume 0 nocap  ## alsamixer mute mic
amixer set Internal Mic Capture volume 0 nocap  ## alsamixer mute mic
amixer set Capture toggle && amixer get Capture | grep '\[off\]' && notify-send "MIC switched OFF" || notify-send "MIC switched ON"  ## mute mic with visual status update
amixer set Master playback volume 30 unmute  ## alsamixer unmute playback volume 30
apropos keyword  ## search man page names and descriptions
arecord --vumeter stereo audio.wav  ## record wave audio
awk '!($1="")' $file  ## remove column 1
awk 'NF{NF-=1};1'  ## remove last column
awk 'NR == 1; NR > 1 {print $0 | "sort -n"}'  ## sort stdin, omit first header line
basename $filepath  ## print filename without any leading directory components
bind '"\e[0n": "$string"'; printf '\e[5n'  ## inject $string to bash stdin
bindkey  ## zsh bound keys
blkid /dev/sda128 | awk '{print $3}' | cut -d '"' -f 2  ## get uuid from /dev/sd
bluetoothctl connect $(bluetoothctl devices | fzf | awk '{print $2}') && bluetoothctl info  ## bluetooth connect
bluetoothctl disconnect $(bluetoothctl devices | fzf | awk '{print $2}') && bluetoothctl info  ## bluetooth disconnect
bluetoothctl discoverable off	## bluetooth not broadcast radio device
bluetoothctl power off && sudo systemctl stop bluetooth.service && sudo rfkill block bluetooth  ## bluetooth radio off
brightnessctl set 50%  ## set brightness to 50% of the maximum
cal -m -w -3 $(date -I)  ## calendar showing last, current and next month, week start on mondays, with weeknumbers
cal -m -w -y $(date +%Y)  ## current year calendar
cal -m -w 12 2022  ## calendar for december 2022
cat $HOME/c/keys/wl/ap.wifi | grep '#psk' | awk -F "\"" '{print $2}' | qrencode -t utf8  ## wifi accesspoint password qr
cat -n $file  ## line number cat
cat -vE $file  ## prevent cat shell injection
cat 0< $file >1 /dev/stdout  ## rudimentary form of: cat $file
cat <(ls)  ## process substitution reading from list <() (?without subshell?); same as ls | cat  (piping ?with subshell?) #DEV
echo hello > >(sha512sum > file_with_hello_sha512.hash)  ## process substitution (instead of filename) writing to list >()
< /etc/group  ## list all user groups
cd $(fd -t d -H -I . $HOME | fzf --preview="tree -L 1 {}" --bind="space:toggle-preview" --preview-window=:hidden)  ## fzf cd from $HOME, spacebar for info box
cd $HOME/.config/hosts; git switch blocklist_on; cd -  ## activate network blocklist
cd $XDG_CONFIG_HOME/shln; sh chln; cd .; cd -  ## change symlinks to current $USER for $PATH
cd /usr/lib/modules/$(uname -r)  ## active os kernel modules
cd /var/lib/pacman/local  ## pacman install directory
cd $(printf '%s\n' "$PWD" | sed "s|$HOME/b|$HOME/c|")  ## move parrallel to the same cwd, but in another parent directory
chattr -R +i $directory  ## add 'i' attribute: files in $directory cannot be modified
chmod --reference=ref_file target  ## make target file mode bits same as ref_file
chown -R $USER:$GROUP $target  ## recursive set target ownership to current user & group
chown :group file  ## set group ownership
chown user: file  ## set user ownership
clear  ## shift current line to top of screen
cmp $lf $rf  ## byte compare files, boolean output
command $command  ## run native $command, no alias or function, \command
cp -prv --attributes-only  ## copy no content, but only mode, ownership and timestamps, verbose
cp -pv  ## copy and preserve mode, ownership and timestamps, verbose
cryptsetup --cipher=aes-xts-plain64 -hash=sha512 --key-size=512 --offset=0 --verify-passphrase open --type=plain /dev/sdX lvm
cryptsetup --cipher=aes-xts-plain64 -hash=sha512 --key-size=512 --offset=0 key-file=/dev/sdZ open --type=plain /dev/sdX lvm
cryptsetup --cipher=serpent-xts-plain -hash=sha512 --key-size=512 --iter-time=4096 --use-random --verify-passphrase luksFormat /dev/sdX
cryptsetup luksAddKey --key-slot 7 $vault  ## add luks key to slot 7 of $vault
cryptsetup luksRemoveKey $vault  ## remove luks key from $vault slot 7
cryptsetup luksDump $vault  ## dump $vault header information
cryptsetup luksChangeKey $vault  ## change a key for $vault
cryptsetup luksUUID $luks_container | wl-copy -o -n  ## get $luks_container id
cryptsetup open /dev/sdX cryptlvm  ## open /dev/sdX to cryptlvm
cryptsetup open /dev/sdX cryptroot --debug  ## which keyslot is used for passphrase
curl $(wl-paste) | zathura -  ## stream a copied (qb ;y) pdf url
curl -4 https://ident.me  ## external ip address
curl -O https://mirror.i3d.net/pub/archlinux/iso/2018.04.01/archlinux-2018.04.01-x86_64.iso | sudo dd of=/dev/sdX  ## download arch linux iso and write to device
curl -O https://file.location -C - -o file.location.txt_part  ## start or resume downloading file.location to file.location.txt_part
curl -O $(wl-paste) -C -  ## start or resume downloading copied location
cut -d , -f 5 --complement file.csv  ## remove column 5 from file.csv
date && sudo hwclock --show --verbose  ## read hardware clock time and its drift
date +'%s'  ## current linux epoch (same as 'now' for oxo)
date -d 'June 28 03:14' +'%s'  ## convert specific date (tau day on pi time) to linux epoch
date -d "$(date -u)" +'%Y-%m-%dT%H:%M:%S%:z'  ## convert current zulu time to ISO8601
date -d '@1234567890' +'%Y%m%d_%H%M%S_%s_%z_%Z_%V'  ## convert specific linux epoch to oxo extensive time format
date -d @$(wl-paste) +'%Y%m%d_%H%M%S_%s_%z_%Z_%V'  ## convert copied specific linux epoch to oxo extensive time format
dd if=$src of=$dst bs=256k iflag=fullblock oflag=sync,noerror,notrunc status=progress  ## physical copy $src to $dst
dd if=/dev/zero of=$dst bs=256k count=1 iflag=fullblock oflag=sync,noerror,notrunc status=progress  ## write 1 * 256*2^10 bytes as zeros to $dst
dd if=/dev/urandom of=$dst bs=256k count=1 iflag=fullblock oflag=sync,noerror,notrunc status=progress  ## write 1 * 256*2^10 random bytes to $dst
df -h  ## human-readable file system space usage
df --si --exclude-type devtmpfs --exclude-type tmpfs --exclude-type efivarfs | awk 'NR == 1; NR > 1 {print $0 | "sort -n"}'  ## file system disk free space
dhcpcd -k $interface  ## dhcp remove interface ip
dhcpcd $interface  ## dhcp request for interface
diff --side-by-side --left-column $lf $rf  ## print $lf; $rf diffs in right column (-y --left-column)
diff --new-file --text --unified=3 --recursive $lf $rf > $patch_file  ## create recursive $patch-file unified with 3 lines of context from $lf to $rf (-Naur)
diff <(echo $(uname -r | grep --only-matching '[[:digit:]]' | tr -d '[:blank:]\t\r\n')) <(echo $(pacman -Q linux | grep --only-matching '[[:digit:]]' | tr -d '[:blank:]\t\r\n')) | tr -d '\n'; echo  ## kernel upgrade requires reboot ($? != 0)
dig -x 89.39.107.195  ## reverse lookup own public ip
dircolors --print-ls-colors  ## evaluate $LS_COLORS colors
dirname $filename  ## print $filename without last component
dotfbu restore $XDG_DATA_HOME/c/git/dotf $XDG_CONFIG_HOME  ## restore oxo configuration
dotool --list-x-keys  ## show xkb keys
du -sbh $directory  ## directory usage; total size of all content in directory
du --bytes --si --human-readable --separate-dirs --max-depth=0 $directory | awk '{print $1}'  ## directory usage; total si size of all files in current $directory
du --bytes --si --human-readable --separate-dirs --total $directory | tail --lines 1 | awk '{print $1}'  ## directory usage; total si size of all files and subdirectories
du --bytes --si --human-readable --separate-dirs $directory | sort -k 2  ## directory usage; list of all subdirectories with sizes (size sort -h -k 1)
du --bytes --si --human-readable --separate-dirs --total --all $directory | sort -k 2  ## directory usage; list of files and subdirectories with sizes (size sort -h -k 1)
e2label /dev/X  ## read device label
e2label /dev/X $label  ## write device label
echo "obase=02; ibase=16; $(echo $hex | tr a-z A-Z)" | bc  ## bc hexadecimal to binary conversion
echo "obase=10; ibase=16; $(echo $hex | tr a-z A-Z)" | bc  ## bc hexadecimal to decimal conversion
echo "obase=16; ibase=10; $dec" | bc  ## bc dec (10) to hex (16) conversion
echo $(( 1 ^ 2 ))  ## decimal value of xor 1 and 2 (xor 01 and 10 = 11)
echo -n $string | base64  ## base64 encoding
echo $?  ## print exit code of the last executed command
echo ${USER%??}$string  ## replace last two (%??) characters of $USER by $string
echo $RANDOM  ## returns pseudorandom integer (0-32767)
echo ${HOME#*/}  ## remove shortest matching pattern from head, until 1st instance ('home/oxo')
echo ${HOME##*/}  ## remove longest matching pattern from head, until last instance ('oxo')
echo ${HOME%/*}  ## remove shortest matching pattern from tail, from last instance ('/home')
echo ${HOME%%/*}  ## remove longest matching pattern from tail, from first instance ('')
wl-paste | sed -n '1p' | sed 's/[^0-9]//g' | cut -c 1-4  ## first four digits from multiline string
wl-paste | grep -Eo '[0-9]' | tail -n 4 | tr -d '[:blank:]\t\r\n'  ## last four digits from multiline string
emacs --daemon  ## start emacs daemon
emacsclient --create-frame --alternate-editor="" $file &  ## client open $file in new gui window
emacsclient --tty $file &  ## client open $file in current terminal window
emacsclient -e '(kill-emacs)'  ## stop emacs daemon outside running instance
(set-face-attribute 'default nil :height 180)  ## ' emacs set font size 18pt (for screencasting)
printenv  ## print values of environment variables
espeak -s 80 -p 70 -v mb-us1 'hello'  ## espeak hello speed 80% pitch 70% voice us1
eval $(ssh-agent) && ssh-add $XDG_DATA_HOME/c/keys/ssh/$ssh_key  ## concatenate arguments, add ssh_key
faillock --user $USER --reset  ## remove sudo lockout for current user
fc  ## edit last command in
fc -l -n -1  ## last command entered, hide line number
fc-list  ## list available fonts (fontconfig)
fd --unrestricted . | fzf --query $(wl-paste) | wl-copy  ## fzf search wl-paste file path and wl-paste (quick file search)
ffprobe -i $media_file -show_entries format=duration -v quiet -of csv="p=0" -sexagesimal  ## get $media_file duration (seconds or sexagesimal)
fg  ## recall last suspended command to foreground
fg %n  ## jobs item n to foreground
figlet -d $XDG_CONFIG_HOME/figlet  ## change default font directory
figlet -f 'mini' oxo  ## figchars
find . -exec $command {} \;  ## find exec structure
find . -maxdepth 1 -name \*_ -type d -exec cp -r {} ~/test_/bu \;  ## find all dirs ending with _ and copy them (NOTICE: '\*_')
find . -maxdepth 1 -type d -exec du -sb {} \; | sort -g -k 1  ## directories sorted by size (bytes)
find . -maxdepth 1 -type f -name "* *" -exec sh -c 'mv "$0" "${0// /_}"' {} \;  ## replace filename spaces with underscores
find . -maxdepth 1 -type f -mtime $n  ## data modified less than (-n), more than (+n) or exactly n*24 hours (days) ago
find . -maxdepth 1 -type f -cmin $n  ## file status changed less than (-n), more than (+n) or exactly n minutes ago
find . -maxdepth 1 -type l -exec cp -d {} $HOME/.dot \;  ## find symlinks and copy without dereferencing
find . -type f ! -newermt "2018-12-31" -delet3  ## find and delete all files older (not newer) than date
find . -type f -exec mv {} $dest \;  ## find all files and move them to $dest directory
find . -type l -exec sh -c "file -b {} | grep -q ^broken" \; -print  ## find broken symbolic links
find . | sed -e 's;[^/]*/;|____;g;s;____|; |;g'  ## similar to: find . | tree
find . -iname $file  ## case_insensitive find
find $directory -name '$search_string' 2>/dev/null  ## find quiet
find $directory -type f -exec shred -v -z -n 3 -u {} \;  ## shred found files
for file in *.html; do mv "$file" "${file%.html}.txt"; done  ## change file extension (*.html to *.txt)
for file in *; do cp -- "$file" "string_$file"; done  ## append string_ to each file in cwd
for i in {0..255}; do; printf "\x1b[38;5;${i}mcolour${i}\x1b[0m\n"; done  ## print 256 colors
for i in {1..65535}; do (echo < /dev/tcp/127.0.0.1/$i) &>/dev/null && printf "\n[+] open port\n: \t%d\n" "$i" || printf "$i\r"; done  ## portscan
for i in {0..7}; do; printf "\033[0;3${i}mcolor$i\n"; done  ## print 8 colors
free -m  ## free and used memory in system
sudo -k; free -h; echo; for i in {1..3}; do; sudo sysctl -w vm.drop_caches="$i"; sudo sync; echo "$i" | sudo tee /proc/sys/vm/drop_caches; done; free -h  ## free mwmory (pagecache, dentries and inodes)
fuser -vmM $file_system  ## display PIDs using file / file(system) (filesystem in mount)
fusermount -u $HOME/dock/mobile  ## umount simple-mtpfs mtp device
getent ahosts $url  ## get ip address from name service switch library database ahost
git config --show-scope --show-origin --list  ## origin and scope of git configuration
git log --oneline  ## list of commits
git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit  ## git hist
git reset --hard 2db93df  ## back to a previous commit
gnutls-cli -d 1 grc.com -p 443  ## get certificate info
gpg --armor --export ID > ID.puk.gpg  ## export public key ascii armored id
gpg --detach-sign --local-user 0x12345678 $file  ## sign $file with specific secret key
gpg --edit-key ID >  ## edit public key
gpg --export ID > ID.puk.gpg  ## export public key binary
gpg --export --export-options backup --output public_keys.gpg  ## step 1 backup gpg identity (public keys)
gpg --export-secret-keys --export-options backup --output private_keys.gpg  ## step 2 backup gpg identity (private keys)
gpg --export-ownertrust > trust_db.gpg  ## step 3 backup gpg identity (trust database)
gpg --import public_keys.gpg  ## step 1 restore gpg identity (public keys)
gpg --import private_keys.gpg  ## step 2 restore gpg identity (private keys)
gpg --import-ownertrust trust_db.gpg  ## step 3 restore gpg identity (trust database)
gpg --fingerprint | grep -i -B 1 $uid_email | head -n 1 | awk -F = '{print $2}' | sed ':a;N;$!ba;s/\n//g' | sed 's/ //g' | sed 's/\r$//g'  ## get gpg fingerprint w/o spaces from uid (email)
gpg --expert --full-generate-key  ## generate new keypair
gpg --import ID >  ## import public key
gpg --list-keys | grep ^uid | sed s'/  //g' | fzf | awk '{print $NF}' | sed 's/<//' | sed 's/>//' | xargs -I {} sh -c "gpg --list-keys | grep -B 1 {}" | head -n 1 | awk -F = '{print $2}' | sed ':a;N;$!ba;s/\n//g' | sed 's/ //g' | sed 's/\r$//g'  ## get fingerprint from fzf uid list
gpg --output ID.puk.asc --armor --export ID >  ## export public key ascii armored
gpg --output file --decrypt file.gpg >  ## decrypt file.gpg asymmetric using private key
gpg --output file.gpg --encrypt --recipient ID file >  ## encrypt file asymmetric using public key ID
gpg --output file.gpg --symmetric file >  ## encrypt file symmetric
gpg -e -a -r $id file  ## encrypt file armored for recipient $id (like pass)
gpg --output revoke.asc --gen-revoke ID  ## generate revocation certificate
gpg -vv $pub_key.asc  ## verbose info on $pub_key.asc
gpg-connect-agent reloadagent /bye  ## clear passphrases gpg cache
gpg-connect-agent 'keyinfo --list' /bye 2>/dev/null | awk 'BEGIN{CACHED=0} /^S/ {if($7==1){CACHED=1}} END{if($0!=""){print CACHED} else {print "0"}}'  ## gpg cache status (1=cached)
gpsbabel -i garmin_fit -f $in_fit -o gpx -F $out_gpx  ## fit2gpx conversion
grep "\sro[\s,]" /proc/mounts  ## show read only mountpoints
grep -riIl 'text' [directory]  ## find files (no binary) containing text recursively in directory
grep -riIn 'text' [directory]  ## find files (no binary) containing text recursively in directory with linenumbers
grep '^[[:blank:]]*[^[:blank:]#;]' $file  ## only lines not (2nd ^) starting (1st ^) with # or ; uncommented lines from file
grep '^[[:blank:]]*[^[:blank:]#;]' $XDG_CONFIG_HOME/alacritty/alacritty.yml | grep 'key:'  ## alacritty active (no outcommented) keybindings
grep bindsym $XDG_CONFIG_HOME/sway/config  ## sway keybinding related lines
grep bindkey $XDG_CONFIG_HOME/zsh/.zshrc  ## zsh keybinding related lines
gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/default -dNOPAUSE -dQUIET -dBATCH -dDetectDuplicateImages -dCompressFonts=true -r150 -sOutputFile=out.pdf in1.pdf in2.pdf in3.pdf  ## concatenate pdf files
gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/default -dNOPAUSE -dQUIET -dBATCH -dDetectDuplicateImages -dCompressFonts=true -r150 -sOutputFile=out.pdf -dFirstPage=a -dLastPage=b $infile.pdf  ## extract pages a through b from $infile.pdf
head -n -3 $file  ## show all but 3 last lines (hide last three lines from $file)
history -t %Y%m%d_%H%M%S -d -D $history_id  ## command history from $history_id (id time-start -elapsed cmd)
history -t %Y%m%d_%H%M%S -d -D -3  ## last 3 commands from history (id time-start -elapsed cmd)
history | tail -n 1 | tr -s ' ' | cut -d ' ' -f 3-  ## last command from history (removing counter)
hmac=$(printf $input | openssl dgst -sha512 -hmac $input | sed 's/^.*= //')  ## zz2
host -t A $ip_addr_domain  ## dns lookup A record
host -v -t ANY $ip_addr_domain  ## dns lookup any type verbose output
hwclock --set --date='01/01/2010 00:00:00'; sudo hwclock --hctosys  ## set date and time
id -u [$USER]  ## show effective user id
id -g [$USER]  ## show effective group id
id -un [$USER]  ## show effective user name
id -gn [$USER]  ## show effective group name
id [$USER]  ## show both real and effective uid & gid
iftop -i $interface ## display bandwith usage of interface
info  ## advanced manual system primarily for gnu programs
insmod $file [$args]  ## insert module into kernel (if not in /usr/lib/modules/$(uname -r))
ip a add 192.168.1.200/255.255.255.0 dev $interface  ## assign ip address to interface
ip a add $ip_subnet_mask broadcast $broadcast_ip dev $interface  ## TODO desription
ip a del 192.168.1.200/24 dev $interface  ## remove ip address from interface
ip a flush $interface  ## remove all ip addresses from interface
ip link set $interface {down/up}  ## change interface state
ip link set dev [$interface] address [$mac]  ## assign [mac] address to [interface]
ip link set dev [$interface] down  ## disconnect from the network by disable interface
ip n show  ## show neighbour / arp cache
ip link show $enp | grep link | awk '{print $2}'  ## print $enp mac address
ip route add default via $default_gateway  ## TODO description
ip route flush dev $interface  ## TODO description
ipset add blocklist [$ipaddrs]  ## add [ipaddrs] to blocklist
ipset create blocklist hash:ip  ## create ip blocklist
iw dev [$wl_interface] scan | grep SSID | sort | uniq  ## received SSID list
jobs  ## list background processes
journalctl --disk-usage  ## show total disk usage
journalctl --flush --rotate  ## flush all journal data from /run to /var and request immediate rotation of the journal files
journalctl --vacuum-files=2  ## leave 2 journal files (--vacuum-size, --vacuum-time)
journalctl --list-boots  ##  ## TODO decription
journalctl -b, --boot [$id]  ## TODO decription
journalctl -e  ## TODO decription
journalctl -f, --follow  ## TODO decription
journalctl -k  ## TODO decription
journalctl -o json-pretty  ## TODO decription
journalctl -o verbose  ## TODO decription
journalctl -p 3 -x  ## TODO decription
journalctl -u $unit  ## TODO decription
journalctl _<TAB>  ## TODO decription
jq '.data[0] | .ua' api.json  ## get ua from the first data item
kill -l  ## list of signal names (/usr/include/linux/signal.h) that can be send to process
kill -STOP %n  ## stop background process jobs item number n
kill $(pidof $process_name)  ## terminate pid of process
ln -s $target $link_name  ## create symlink $link_name to $target
ln -s -f $target $link_name  ## replace symlink $link_name to $target
losetup -l -a  ## list all loop devices
losetup -d $loop_dev  ## detach $loop_dev
ls $XDG_DATA_HOME/keys/wl | fzf | xargs -r cat | grep #psk | awk -F "\"" '{print $2}' | qrencode -t utf8  ## fzf select wifi key and show qr
lsblk -i --tree -o name,fstype,uuid,path,size,fsuse%,fsused,label,mountpoint  ## list block devices
lsblk -o fsuse%,path,fsused,size | grep '%' | awk 'NR == 1; NR > 1 {print $0 | "sort -nr"}'  ## block devices usage percentage
lscpu  ## display cpu architecture
lshw  ## list hardware configuration
lsmod  ## list drivers currently added to kernel
lsof +f -- [$path1 $path2]  ## list open files in paths opened by processes
lsof -p [$pid]  ## list open files for PID
lspci  ## list pci devices
lspci -k -d #[$vendor]:[$device][:$class]  ## TODO decription
lspci -k -s xx:xx.x #[[$domain]:]$bus]:][$slot][.[$func]]  ## TODO decription
lspci -kvvt  ## TODO decription
lspci -vv  ## list pci devices, find kernel drivers
man -k . | fzf | awk '{print $1}' | xargs -r man  ## fzf search apropos and open manpage
man ascii  ## 7-bit ascii tables
man zshall  ## view the system reference manual for all zsh
mkdir $HOME/dock/{1-4}  ## make multiple directories
tmp=$(mktemp); printf "$tmp\n"; head -c 1b </dev/urandom >"$tmp"  ## create a temporary file with 1b random data
nmcli connection add type ethernet con-name $con_name ifname $if_name  ## TODO decription
nmcli connection modify $con_name ipv4.addresses 192.168.0.39/24 ipv4.gateway 192.168.2.2 ipv4.dns 192.168.2.2 +ipv4.dns 9.9.9.9 connection.autoconnect no ipv4.method manual  ## TODO decription
modprobe -r $driver  ## remove driver from kernel
modprobe $driver  ## add driver to kernel
mount -L $label $mountpoint  ## mount device with $label to $mountpoint
mount -o remount,rw /dev/sdY1 /boot  ## remount rw existing mountpoint
mount -o uid=$(id -u $USER),gid=$(id -g $USER) /dev/sdX dock/1  ## mount as current user
mount -t tmpfs tmpfs /mnt/ramdisk -o size=4096  ## create ramdisk
mount | grep ro,  ## find all ro mountpoints
mount | sort -k 1 | column -t  ## sort mount by device name
mount | sort -k 3 | column -t  ## sort mount by mountpoint
export PWGN_OFF=1; mountr  ## disable oxo pwgn
mpv --start=+00:00 --ytdl-format='best[filesize<300M]' --profile=cache_xs --demuxer-cache-wait --msg-level=all=v --http-header-fields="User-Agent: $(head -n 1 $USER_AGENT)" $(wl-paste)  ## stream movie verbose with mpv.conf cache_s profile
mpv $(echo $url | sed 's/https:\/\/www.youtube.com\/watch?v=/https:\/\/youtu.be\//')  ## change yt url
mpv --audio-display=no $file.mp3  ## play mp3 without albumart
mpv /dev/video4  ## livestream local webcam
mv -t $target_dir $source_dirs  ## move source_dirs to target_dir
nerd-dictation begin --config $config_file --simulate-input-tool STDOUT --numbers-min-value 10 --numbers-as-digits --numbers-no-suffix --vosk-model-dir $model_dir  ## speech-to-text
neofetch --ascii_distro arch_small --gtk3 off --gtk2 off --colors 3 3 3 7 3 4 --separator '     \t'  ## neat system info
nl -w 3 -s ' '  ## add line numbers with number width 3 and separator string ' '
notmuch address '*'  ## all mail addresses
notmuch address --output=recipients --deduplicate=address date:year | fzf | wl-copy  ## last years recipients
notmuch address --deduplicate=address date:year | fzf | wl-copy  ## 1. last years email addresses
notmuch search $(wl-paste) date:year | fzf | awk '{print $1}' | wl-copy  ## 2. last years threads from recipient
notmuch show $(wl-paste)  ## 3. show specific thread content
notmuch address --output=count --deduplicate=address date:year '*' | sort --numeric-sort --reverse | fzf | wl-copy  ## last years email addresses, most to least active
nslookup server.com  ## get server ip address
openssl enc -d -base64 -aes-256-gcm -pbkdf2 -salt -in crypt.aes -out plain.txt  ## openssl base64 encoded aes 256 bits galois counter mode decryption
openssl enc -e -base64 -aes-256-gcm -pbkdf2 -salt -in plain.txt -out crypt.aes  ## openssl base64 encoded aes 256 bits galois counter mode encryption
openssl s_client -connect grc.com:443 -showcerts < /dev/null | openssl x509 -outform pem > cert.pem  ## write x509 public key certificate from grc.com:443 as pem to file cert.pem
openssl s_client -connect $(wl-paste -n):443 -showcerts < /dev/null | openssl x509 -noout -text ## print x509 public key certificate as text to stdout
openssl s_client -connect $server_ip:443 -servername $server_name -showcerts  ## print x509 public key certificate from $(wl-paste -n):443 as text to stdout with server name indication (SNI) in the clienthello message (if a reverse proxy ip serves multiple webservers)
openssl x509 -in cert.pem -noout -text  ## print x509 public key certificate from file cert.pem as text to stdout
openvpn --config openvpn/udp-ams1_udp.ovpn  ## TODO decription
output=$(printf $input | openssl dgst -sha512 -hmac $hmac | sed 's/^.*= //')  ## zz3
pacman-key --delete $pub_key  ## TODO decription
pacman-key --finger $pub_key  ## TODO decription
pacman-key --lsign-key $pub_key  ## TODO decription
pactl list sinks | grep -A 1 Name  ## list of sink devices (audio output)
pactl list sources | grep -A 1 Name  ## list of source devices (audio input)
pactl set-source-port $device_name $port_name  ## set audio source (use tab to autocomplete)
pactl set-source-volume $device_name 100%  ## set audio source volume 100% (use tab to autocomplete)
pactl set-source-mute $device_name false  ## set audio source mute status false (use tab to autocomplete)
pactl list sources | grep -B 1 'Webcam C310 Mono' | head -n 1 | awk '{print $2}'  ## get audio source name from description (for wf-recorder --audio)
pactree -r $package  ## show $package dependant tree, reverse depedencies, packages that depend on $package
pactree $package  ## show $package dependency tree
patch -p0 < $patch_file  ## apply $patch_file (see diff)
pim2fa=$(printf $input | openssl dgst -sha512 -hmac pim2fa | sed 's/^.*= //')  ## zz4
pim=$(printf $input | xxd -p)  ## zz4_OLD
ping -D -i 10 -c 5 9.9.9.9  ## TODO decription
pkill wpa_supplicant && sudo dhcpcd -k wlp58s0 && sudo pkill dhcpcd && sudo ip a flush wlp58s0  ## end internet connection
pkill -SIGRTMIN+4 i3blocks  ## send signal=4 to i3blocks
print -z $string  ## inject $string to zsh stdin
printf "$tring" | awk '{print $1+0}'  ## awk retrieves the second field as a number (+0) from $tring, anything after the number will be ignored
printf "%03d%s" "2"  ## print leading zeros
printf "%3d%s" "2"  ## print leading spaces
printf "%d\n" \'A  ## character (A) to ascii value (65)
printf "${fg_black}$(BGx aaaaaa)%s${st_def}\n" 'text_appearance'  ## printf 24 bit hex color code; NOTICE dependency: oxo source function text_appearance
printf "Mime-Version: 1.0; Content-Type: text/plain; charset=us-ascii; Content-Transfer-Encoding: 7bit; Subject: <subject>\n; <body>" | msmtp -v -C <msmtp_config> -a <profile_name> -- destination@mail.com  ## send email
printf "\x$(printf %x 65)"  ## ascii value (65) to character (A)
printf "space_every_4th_char" | fold -w 4 | paste -sd ' ' -  ## space every 4th character (with fold)
printf "space_every_4th_char" | sed 's/.\{4\}/& /g'  ## space every 4th character (with sed)
printf $(( [#n] x ))  ## print base 10 value of x in base n, with 2<=n<=36
printf text | openssl dgst -sha512 -hmac key | sed 's/^.*= //' | wl-copy
ps -ajxf  ## print a process tree
ps -eFly  ## list every process on the system
ps -eo %cpu,%mem,pid,pgid,user,state,start,args= --sort=-etimes  ## list processes custom AIX format descriptors, sort low to high elapsed time since process was started
ps -eo %cpu,%mem,pid,user,command= --sort=-%cpu  ## list processes custom AIX format descriptors, sort high to low cpu usage
pstree -ptg  ## display a tree of processes, show PIDs, PGIDs and full names for threads
PS4=':${BASH_SOURCE[0]:-$0} $(printf %4d%s "${LINENO}") ${FUNCNAME[0]:+${FUNCNAME[0]}(): }' sh -xv script.sh  ## extra verbose debug output stream
pushd $directory  ## cd to $directory and add $directory to dirs stack[0]
qalc '-18.5458 to latitude'  ## convert decimal geographic position value to sexagesimal N/S notation
qalc '64.8587 to longitude'  ## convert decimal geographic position value to sexagesimal E/W notation
qalc '18°32′44.88″W to degrees'  ## convert sexagesimal value to decimal geographic position notation
qalc -s 'exp engineering' '1700000000'  ## convert value to engineering notation
qbns -s content.canvas_reading true -s content.webgl true -s colors.webpage.darkmode.enabled false $(wl-paste) &  ## qutebrowser new session open copied url unsafe
qrencode -t utf8  ## create qr from stdin
qutebrowser -s content.canvas_reading true  ## qb for windy
rankmirrors -n 10 /etc/pacman.d/mirrorlist | grep -w 'Server =' >> mirrorlist.ranked  ## update mirrorlist
read -r input  ## zz1; variable is assigned
read -er input  ## zz1; variable is not assigned
read -er input | tr -d '\n' | base64 | tr -d '\n' | wl-copy -n -o  ## input base64 translation without EOL
read -er input | base64 | wl-copy -n -o  ## input base64 translation
read -er input | tr -d '\n' | base64 | tr -d '\n' | openssl dgst -sha3-512 | sed 's/^.*= //'  ## secure sha3-512 hash from stdin (verify pwgn)
read -er input | base64 | wl-copy -n -o; dotfbu backup $XDG_CONFIG_HOME $XDG_DATA_HOME/c/git/dotf; gacp_all  ## backup oxo configuration and remote push
read -r script_name; printf '%s%s' "$(figlet "$script_name")" "$(figlet -f mini "$USER")" | wl-copy  ## script header
readlink $symlink  ## print resolved symbolic links or canonical file names
readlink -f $symlink | cut -d / -f 4- | awk -v home="$HOME/" '{print home $0}'  ## change canonicalized symlink to current users $HOME (NOTICE realpath is preferred)
realpath file  ## return canonicalized absolute pathname
realpath $dir_in_home | sed "s|$HOME||"  ## remove $HOME from $dir_in_home
reflector --verbose --protocol https --country Iceland,Sweden,Germany,Denmark,Netherlands,United States --age 12 -l 5 --sort rate --save /etc/pacman.d/mirrorlist  ## generate pacman mirrorlist
rename 'part' '' $filepart  ## change 'part' in filename $filepart with '' (remove part of filename)
renice -19 $(pgrep $process_name)  ## give $process_name highest (-19) priority
reset && zsh  ## reinitialize terminal state and z-shel
return $code  ## exit function with optional $code or failure
rev $file  ## reverse line characters
rfkill list  ## check hard and soft block status wireless radios
rfkill [un]block bluetooth  ## soft [un]block bluetooth radio
rfkill [un]block wlan  ## soft [un]block wifi radio
rm -rf -- '-r'  ## remove entire directory starting with a '-'
rmmod $module  ## remove $module from linux kernel
rsync --recursive $src $dst  ## create intervening directory $dst/$src; with all content of $src
rsync --recursive $src/ $dst  ## copy $src content 'flat' into $dst (like cp $src/.) NOTICE rsync trailing slash caveat
rsync -aAXv --delete --info=progress2,stats --progress $source/ $destination  ## basic oxo rsync
rsync -aAXv --dry-run --delete --info=progress2,stats --progresss $XDG_DATA_HOME/c/ $XDG_DATA_HOME/b  ## dry run backup_c2b
rsync -aAXv --delete --info=progress2,stats --progress --exclude-from=$exclude_patterns $source/ $destination  ## basic oxo rsync w exclude patterns
rsync -aAXv --delete --info=progress2,stats --progress --files-from=$list_relative_to_source $source/ $destination  ## basic oxo rsync w files from patterns
rsync -aAXv --delete --info=progress2,stats --progress --rsh=ssh $source $user@$host:/directory  ## basic oxo rsync w remote ssh shell
rsync -aAXv --hard-links --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/media/*","/var/lib/dhcpcd/*","/lost+found","$dst/*"} / $dst  ## full system backup
script; $command; exit  ## $command execution typescript user log
script; sh -x $command; exit  ## $sommand execution typescript developer debug log
script --command 'sh -x $command' --log-io "$(now).log" --log-timing "$(now).log"  ## $sommand execution typescript developer debug log_2
sed ':a;N;$!ba;s/\n//g' | sed 's/ //g' | sed 's/\r$//g'  ## remove all spaces from string
sed -i "$(( $( wc -l < $HISTFILE ) -1 )),\$d" $HISTFILE  ## remove $HISTORY last line
sed -i '$d' $HISTFILE; sed -e ':t;N;$!bt; s/\(\n[^\n]*\)\{1\}$/\n     deleted:&/' $HISTFILE | tail; sed -i '$d' $HISTFILE  ## remove $HISTORY last line and show result
sed -i '$d' $file  ## remove last line from $file
sed -i '/pttrn/d' file  ## delete all lines in file that contain 'pttrn'
sed -i '2,$d' $file  ## remove all lines from line 2 from $file
sed -i '2,3 d' $file  ## remove line 2 and 3 from $file
sed -i 'ni insert this into line n of file' $file  ## TODO decription
sed -i 's/$find/$replace/g' $file  ## replace $find with $replace in $file
sed -i '/$find/{n;s/.*/$replace/}' $file  ## find $find and replace next line with $replace
sed -i -n -e :a -e '1,2!{P;N;D;};N;ba' $file  ## remove last 2 lines from $file
sed -i '/^find/ s/./#&/' $file  ## comment out lines containing 'find'
set -euo pipefail  ## exit on: -e command error, -u unset variable expansion error, -o pipefail
set -o errexit -o nounset -o pipefail  ## exit on: -e command error, -u unset variable expansion error, -o pipefail
setfont ter-v32n  ## set console font
setopt interactive_comments  ## threat string after '#' as comment (unsetopt disables)
showkey --ascii --scancodes --keycodes  ## examine codes sent by the keyboard
shred --iterations=3 --zero --remove=wipesync --verbose $file  ## overwrite 3 times with random data, zero content, deallocate and remove $file
simple-mtpfs --list-devices  ## list mountable mtp devices
simple-mtpfs -o allow_other --device 1 $HOME/dock/mobile  ## mount mtp device 1
echo 'string2sort' | grep -o . | sort | tr -d "\n"  ## sort chars in string
sort $HISTFILE | uniq -c | sort -k1,1nr -k2 >> history_freq  ## create history frequency list
sort < $file | sort -nr > $file_sort_freq  ## reverse numerical sort
sort < $file | uniq -u > $file_uniq  ## unique lines
sort $file | uniq -c | sort -k1,1nr -k2 | sed 's/^ *[0-9]* //' > file_freq_sort  ## sort columns: k1 numeric reverse then k2
source $function_text_appearance; printf "$(FHX ffbf00)$(BHX 0040ff)%s${NOC}\n" "$text"  ## hexadecimal 24 bit color codes in printf (fore- & background)
split $file -b N  ## split $file into files with N bytes
split $file -l N  ## split $file into files with N lines
split $file -n N  ## split $file into N files
sqlitebrowser $XDG_DATA_HOME/qutebrowser/history.sqlite  ## view qb history
sqlite3 -header -separator " " $XDG_DATA_HOME/qutebrowser/history.sqlite "select * from History;" | fzf --header-lines=1  ## fzf qb history
ssh-keygen -t ed25519-sk -C $key_id -f $key_file  ## generate openssh key
ssh-keygen -R 192.168.0.195  ## remove cached key for ip on the local machine
ssh-keyscan -t ecdsa 192.168.x.y >> ~/.ssh/known_hosts  ## update ecdsa key for ip on local machine
stat -c %A $file  ## display file access rights in human readable format
stat -c %a $file  ## display file access rights in octal format
stat $file  ## display file or file system status
stty -a  ## print all terminal line settings (human readable)
stty -g  ## print all tty settings (stty readable)
stty $(head -n 1 $XDG_CONFIG_HOME/tty/default)  ## (re)set default tty settings
ts="$(now)"; stty_bu="$XDG_CONFIG_HOME/tty/"$ts"_sttyrc"; stty --save > $stty_bu && stty -all >> $stty_bu  ## backup terminal characteristics
sudo -k  ## invalidate cached credentials
sudo -l  ## list allowed commands for user
sudo -n echo >/dev/null 2>&1; echo $?  ## print sudo status
sudo ip link set up && sudo dhcpcd  && ping -c 1 9.9.9.9 && ip a  ## TODO decription
sudo iptables -A INPUT -s [ipaddr] -j DROP  ## add [ipaddr] to chain INPUT and drop all traffic
sudo rfkill unblock bluetooth && sudo systemctl start bluetooth.service && bluetoothctl power on && bluetoothctl discoverable off  ## bluetooth radio on
sudo systemctl start sshd  ## TODO decription
swaymsg -t get_outputs  ## TODO decription
swaymsg -t get_tree | jq -r '.nodes[].nodes[] | select(.type=="workspace").name'  ## list sway workspaces
swaymsg -t get_tree | jq -r '.nodes[].nodes[].nodes[] | select(.type=="con").name'  ## list sway containers
swaymsg -t get_tree | jq -r '.nodes[].nodes[].floating_nodes[].name'  ## list sway floating containers
swaymsg -t get_tree | jq -r 'recurse(.nodes[], .floating_nodes[]) | select(.shell) | "\(.id) \(.pid) \(.app_id // .window_properties.class) \(.name)"' | fzf -m | cut -d ' ' -f 1 | xargs -I {} swaymsg '[con_id={}]' kill  ## kill sway nodes (windows / frames) with fzf
swaymsg -t get_tree | jq -r 'recurse(.nodes[], .floating_nodes[]) | select(.shell) | "\(.id) \(.pid) \(.app_id // .window_properties.class) \(.name)"' | fzf | cut -d ' ' -f 1 | xargs -I {} swaymsg '[con_id={}]' focus  ## focus sway node (window / frame) with fzf
swaymsg -t get_tree | jq -r 'recurse(.nodes[], .floating_nodes[]) | select(.shell) | "\(.id) \(.pid) \(.app_id // .window_properties.class) \(.name)"' | grep float | cut -d ' ' -f 1 | xargs -I {} swaymsg '[con_id={}]' kill  ## kill all nodes whose name containing 'float'
ts=$(now); syncr $HOME/dock/transfer/x1c/home/oxo --delete --links --log-file=$XDG_LOGS_HOME/syncr/$ts | tee -a $XDG_LOGS_HOME/syncr/$ts  ## syncr backup with logging
echo '1' | sudo tee /proc/sys/kernel/sysrq  ## # obtain full sysrq priviledges
sysrq reisub  ## reboot
sysrq reisuo  ## shutdown
systemctl --failed  ## failed services
systemctl isolate graphical.target  ## TODO decription
systemctl isolate multi-user.target  ## TODO decription
systemctl list-unit-files  ## TODO decription
systemctl list-units  ## TODO decription
systemd-analyze  ## TODO decription
tail -f /var/log/{messages,kernel,dmesg,syslog}  ## TODO decription
tac $file  ## concatenate and print file lines in reverse
tar -cv[j/z]f $archive.tar -C $subdir $files  ## create tar archive [bzip2/gzip compression (optional)] files in archive relative to $subdir
tar -cv[j/z]f $archive.tar $files  ## create tar archive [bzip2/gzip compression (optional)]
tar -tvf $archive.tar  ## print contents of tar archive
tar -xv[j/z]f $archive.tar  ## extract tar archive [bzip2/gzip compression (optional)]
tar -xv[j/z]f $archive.tar $path/single.file  ## extract single.file from tar archive [bzip2/gzip compression (optional)]
tee -a $file1 $file2  ## append stdout to multiple files
tmux attach-session -t 0  ## TODO decription
tmux show-options -g  ## TODO decription
touch --date=2000/01/01 $file  ## create file in time
tput reset  ## reinitialize terminal state
tr -d '[:blank:]\t\r\n'  ## remove all whitespace
tr -s ' ' < file_with_double_spaces > file_without_double_spaces  ## squeeze repeats; remove double spaces
tr -d -c "[:alnum:]" < /dev/random | head -c 32  ## translate random stream in 32 alnum (alphanumeric) character class characters (generate passstring)
tr -d -c "[:graph:]" < /dev/random | head -c 32  ## translate random stream in 32 graph (printable without spaces) character class characters (generate passstring)
tr -d -c "[:alnum:]"'~!@#$%^&*()-=[];\,./_+{}:|<>?' < /dev/urandom | fold -w 32 | head -n 16 | cat -b  ## translate 16 random streams in 32 specified characters (generate passstring)
tr -d -c "[:alnum:]"'~!@#$%^&*()-=[];\,./_+{}:|<>?' < /dev/urandom | fold -w 32 | head -n 16 | cat -b | fzf --height=17 --prompt=' select passstring: ' | awk '{print $2}' | wl-copy -o -n  ## TODO decription
trap "tput cnorm; return 1" SIGINT; while true; do tput civis; echo; figlet -f banner3 $(date +'%H%M%S'); sleep 1; for i in {1..8}; do tput el; tput cuu1; done; done  ## figlet clock (screencast)
fallocate -l 5M file  ## create file 5M size
truncate -s 5M file  ## create file 5M size
tree -n --charset=unicode  ## depth indented file listing
type -a file or command  ## file or command interpretation; print all occurences in path
umount -l $mountpoint  ## umount busy targets (mountpoints)
unlink $link_name  ## remove $link_name (i.e. symlink)
unset varfun  ## unset value and attribute of variable or function varfun
unsetvar=  ## set variable unsetvar to ''
uptime  ## uptime since boot
< /proc/uptime | awk '{print $1}'  ## uptime in seconds
usermod -a -G group_2_add user_2_add  ## add user to group
var="${var_1:-$default_var}"  ## var is $default_var if var_1 is unset or null
vlock -a  ## console lock all sessions
env TERM=xterm watch --differences --no-title --interval 1 lsblk --ascii --tree -o name,uuid,fstype,path,size,fsuse%,fsused,label,mountpoint  ## watch lsblk w/ inverted text
watch -n 1 'ls -ilatr'  ## watch ls -ilatr
wev -f wl_keyboard  ## show wayland keyboard events; keyID keynames
wf-recorder --audio --codec libx264 --file $video.mp4  ## recording video for odyssee
wget https://file.location -c -O file.location.txt_part  ## resume downloading file.location to file.location.txt_part
which -a $command  ## show path of all $command (from $PATH)
optstring=":i:h"; while getopts $optstring opt; do; case $opt in i) var="${OPTARG}";; h) echo help_text;; \?) echo 'no opt';; :) echo 'hlp txt';; esac; done  ## command options (-i arg or -h)
while IFS= read -r pkg; do ls /var/cache/pacman/pkg | grep ^"$pkg"; done <<< "$(pacman -Qm | awk '{print $1}')"  ## which package from Qm is in /v/c/p/p
while read -r -u $fd l; do $commands; done {fd}< $file  ## read file line by line into l (with stdin redirection)
while read l; do $commands; done < $file  ## read file line by line into l
whois -B 46.166.142.215  ## whois own public ip
wl-paste >> /home/cytopyge/.config/qutebrowser/bookmark_urls  ## add to bookmark_urls
wf-recorder -g "$(slurp)"  ## video capture part of screen
wf-recorder --audio --file=recording_with_audio.avi  ## capture whole screen with audio
read -er -p 'SSID?' ssid | wpa_passphrase "$ssid" > "$SSID".wifi  ## generate wl access file
wpa_supplicant -B -i wlp58s0 -c ~/keys/wl/mn.wifi  ## TODO decription
xargs --no-run-if-empty --verbose command  ## run command with stdin as argument, no-run if empty
xxd -b -p $infile $outfile  ## plain bits dump
xxd -p $infile $outfile  ## plain hexdump
xxd -r -p $infile $outfile  ## reverse plain hexdump
xz -d  ## decompress .xz file
xz -l  ## list .xz file
xz -z  ## compress .xz file
yay --gendb  ## generate developement package database
yay --show -w -w  ## TODO decription
yay -Gd $(yay -Qqm)  ## download package builds from installed aur packages
yay -P  ## show (is a yay specific [no pacman] option)
yay -Ps && yay --show -w && yay -Syu && yay -Rns $(yay -Qtdq) && paccache -rv  ## system upgrade and cleanup
yay -Pw  ## show news
yay -Q  ## query package database; display installed packages with version (Q=Qd+Qe=Qm+Qn)
yay -Qc $file	## query package database; display changelog $file  ## TODO decription
yay -Qd  ## (--deps) query package database; display packages installed as dependencies
yay -Qdt  ## query package database; display unrequired deps
yay -Qe  ## (--explicit) query package database; display explicitly installed packages
yay -Qent  ## query package database; display explicitly installed (no dependencies), not required packages that are in the package database
yay -Qg $group  ## query package database; display packages that are member of $group
yay -Qi $package  ## query package database; display package infoos that are member of $groupcman
yay -Qk $package  ## query package database; display number of total and missing files, check that all files of the package are present on the system
yay -Ql $package  ## query package database; display package file list
yay -Qm  ## (--foreign) query package database; display packages that are not in the sync database
yay -Qmq  ## (--foreign) query package database; display packages that are not in the sync database no version
yay -Qn  ## (--native) query package database; display packages that are in the sync database
yay -Qnq | yay -S -  ## reinstall native packages
yay -Qo $file  ## query package database; display which package owns $file
yay -Qq  ## query package database; display installed packages (raw)
yay -Qql $package  ## query package database; display package file list (raw)
yay -R $package || $group  ## remove [package] OR [group]
yay -Rns $package  ## remove [package] including not required and not explicitly installed dependencies, no pacsave
yay -Rns $(yay -Qdtq)  ## remove unrequired dependencies including not required and not explicitly installed dependencies, no pacsave
yay -S $package  ## synchronize package; download and install
yay -Sc $package  ## remove all cached packages that are currently not installed (more agressive than paccache)
yay -Scc $package  ## remove all cached packages (far more agressive than paccache, will prevent downgrading or reinstalling without downloading)
yay -Sii $package  ## extended package info; reverse dependencies; package required by
yay -Sw $package  ## synchronize package only download, not install
yay -Syu --devel --timeupdate  ## update, also check AUR developement packages (git), timeupdate (instead of version number)
yay -Tv  ## check dependencies; show file paths
yay -U $package  ## remove then upgrade or add package
ykman otp static --no-enter --keyboard-layout US 2 'string'  ## assign string to yk slot 2
zbarcam --oneshot --raw /dev/video4 | wl-copy -o -n  ## read qr from video4
zsh --no-rcs  ## zsh terminal without run command script
chmod 0000  ## ---------- 	ugo -	no permissions
chmod 0111  ## ---x--x--x 	ugo x				execute
chmod 0222  ## --w--w--w- 	ugo w			write
chmod 0333  ## --wx-wx-wx 	ugo wx			write	execute
chmod 0444  ## -r--r--r-- 	ugo r	read
chmod 0555  ## -r-xr-xr-x 	ugo xr	read			execute
chmod 0666  ## -rw-rw-rw- 	ugo	rw	read	write
chmod 0777  ## -rwxrwxrwx 	ugo	rwx	read	write	execute
chmod 0700  ## -rwx------ 	u	rwx	g	-	o	-
chmod 0740  ## -rwxr----- 	u	rwx	g	r	o	-
chmod 0770  ## -rwxrwx--- 	u	rwx	g	rwx	o	-
case $expr in pattern1) echo 1 ;; ptrn2) echo 2 ;; *) echo 3 ;; esac  ## case statement basic structure
if [[ $i -eq 0 ]]; then; echo 0; elif [[ $i -lt 0 ]]; then; echo neg; else; echo pos; fi  ## if elif else statement basic structure
for i in 1 2 3; do; echo $i; done  ## for loop basic structure; hardcoded list values
for (( i=$in; i<=$ix; i++ )); do echo $i; done  ## for loop alternative mathematic structure; variable list values (in to ix step i++)
for i in $space_sep_string; do; echo $i; done  ## for loop through space separated string
select option in 'a' 'b' 'c'; do echo "selection: $option"; break; done  ## select basic structure
while read line; do; echo $line; done <<< "$variable"  ## while loop through lines in $variable (heredoc)
while [[ $i -lt 3 ]]; do echo $i; ((i+=1)); done  ## while loop basic structure upcount
while [[ $i -lt 3 ]]; do echo $i; ((i++)); done  ## while loop basic structure upcount
until [[ $i -gt 3 ]]; do echo $i; ((i+=1)); done  ## until loop basic structure upcount
while [[ $i -gt -3 ]]; do echo $i; ((i--)); done  ## while loop basic structure downcount
until [[ $i -lt -3 ]]; do echo $i; ((i--)); done  ## until loop basic structure downcount
break  ## current loop exit
continue  ## current loop next item
reset  ## clear + reset internal terminal state + 1sec delay
tput reset  ## same as reset but without 1sec delay
stty sane  ## don't clear screen but reset some terminal options
echo -e "\033c"  ## same as tput reset but hardcoded escape seq
printf "\033c"  ## same as tput reset but hardcoded escape seq
setterm -reset  ## same as tput reset, setterm has more user friendly commands
print_entire_array() { declare -n __p="$1"; for k in "${!__p[@]}"; do printf "%s=%s\n" "$k" "${__p[$k]}" ; done }  ## print_entire_array arrayX
cat <<- EOF >> file\n multi\nline\ntext\nmlt\nEOF\n  ## append mlt to file (heredoc), strip leading tabs from mlt (-), EOF can be any unique limit string
