<!doctype html><html lang=en-us data-theme=dark><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://thevaluable.dev/images/2020/zsh/zsh.jpg"><meta name=twitter:title content="Configuring Zsh Without Dependencies"><meta name=twitter:description content="Command-line interfaces can solve many problems developers have. It's important to have a good shell, like Zsh, to leverage their power."><meta name=twitter:site content="@Cneude_Matthieu"><meta property="og:title" content="Configuring Zsh Without Dependencies"><meta property="og:site_name" content="The Valuable Dev"><meta property="og:url" content="https://thevaluable.dev/zsh-install-configure-mouseless/"><meta property="og:description" content="Command-line interfaces can solve many problems developers have. It's important to have a good shell, like Zsh, to leverage their power."><meta property="og:type" content="article"><meta property="article:published_time" content="2020-07-27T00:00:00Z"><meta property="article:tag" content="Tools"><meta property="article:tag" content="Mouseless"><title>Configuring Zsh Without Dependencies</title><meta name=description content="Command-line interfaces can solve many problems developers have. It's important to have a good shell, like Zsh, to leverage their power."><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://thevaluable.dev/images/favicon.png><link rel=apple-touch-icon href=https://thevaluable.dev/images/apple-touch-icon.png><link rel=stylesheet class=light-theme href=https://thevaluable.dev/css/screen.min.5c85f9d4527987fa7a925afdf2d38a4cc61a3f06927734d8cbcf5aa42c4e0921.css integrity="sha256-XIX51FJ5h/p6klr98tOKTMYaPwaSdzTYy89apCxOCSE="><link rel=stylesheet class=light-theme href=https://thevaluable.dev/css/footer.min.e2cc02bae8873f6086361a606bf2a0b6b52be606c7ad95ae0952b61d2a0daafa.css integrity="sha256-4swCuuiHP2CGNhpga/KgtrUr5gbHrZWuCVK2HSoNqvo=" media=none onload='this.media="screen"'><link href=https://thevaluable.dev/index.xml rel=alternate type=application/rss+xml title="The Valuable Dev"><meta name=generator content="Hugo 0.109.0"><link rel=canonical href=https://thevaluable.dev/zsh-install-configure-mouseless/><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","image":"https:\/\/thevaluable.dev\/images\/2020\/zsh\/zsh.jpg","publisher":{"@type":"Organization","name":"Matthieu Cneude","logo":{"type":"ImageObject","url":"https:\/\/thevaluable.dev\/images\/author.jpg"}},"author":{"@type":"Person","name":"Matthieu Cneude"},"headline":"Configuring Zsh Without Dependencies","name":"Configuring Zsh Without Dependencies","wordCount":3877,"timeRequired":"PT19M","inLanguage":{"@type":"Language","alternateName":"en"},"url":"https:\/\/thevaluable.dev\/zsh-install-configure-mouseless\/","datePublished":"2020-07-27T00:00Z","dateModified":"2022-02-09T00:00Z","keywords":"Tools, Mouseless","description":"Command-line interfaces can solve many problems developers have. Its important to have a good shell, like Zsh, to leverage their power.","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/thevaluable.dev\/zsh-install-configure-mouseless\/"}}</script><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-46898153-4","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script></head><body class=nav-closed><div class=nav><h3 class="nav-title nav-main-title">Menu</h3><a href=# class=nav-close><i class="la la-times-circle"></i></a><ul><li class=nav-opened role=presentation><a href=https://thevaluable.dev/>Home</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/post/>All Articles</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/page/newsletter/>Let's Connect</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/page/books/>Books</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/page/support/>Support</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/page/about>About</a></li><hr class=separation><h3 class="nav-title nav-sub">Categories</h3><li class=nav-opened role=presentation><a href=https://thevaluable.dev/tags/complexity>Complexity</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/tags/fundamentals>Fundamentals</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/tags/mouseless>Mouseless</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/tags/vim>Vim</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/tags/soft-skills>Soft Skills</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/tags/learning>Learning</a></li><li class=nav-opened role=presentation><a href=https://thevaluable.dev/tags/side-project>Side Projects</a></li></ul><a class=subscribe-button href=https://thevaluable.dev/index.xml><i class="la la-feed"></i>&nbsp;&nbsp;RSS</a></div></div><span class=nav-cover></span><div class=site-wrapper><aside class="table-of-content tob-closed"><a href=# class=tob-close><span class=hidden>Close</span></a><nav id=TableOfContents><ul><li><a href=#brief-unix-shell-overview>Brief Unix Shell Overview</a></li><li><a href=#bash-vs-zsh>Bash vs Zsh</a></li><li><a href=#zsh-without-oh-my-zsh>Zsh Without oh-my-zsh</a></li><li><a href=#let-the-party-begin>Let The Party Begin</a><ul><li><a href=#installing-zsh>Installing Zsh</a></li><li><a href=#zsh-config-files>Zsh Config Files</a></li><li><a href=#zsh-config-path>Zsh Config Path</a></li></ul></li><li><a href=#zsh-basic-config>Zsh Basic Config</a><ul><li><a href=#environment-variables>Environment Variables</a></li><li><a href=#aliases>Aliases</a></li><li><a href=#zsh-options>Zsh Options</a></li><li><a href=#zsh-completion-system>Zsh Completion System</a></li><li><a href=#pimp-my-zsh-prompt>Pimp My Zsh Prompt</a></li><li><a href=#zsh-directory-stack>Zsh Directory Stack</a></li><li><a href=#zsh-by-default>Zsh By Default</a></li></ul></li><li><a href=#zsh-with-vim-flavors>Zsh With Vim Flavors</a><ul><li><a href=#activating-vi-mode>Activating Vi Mode</a></li><li><a href=#changing-cursor>Changing Cursor</a></li><li><a href=#vim-mapping-for-completion>Vim Mapping For Completion</a></li><li><a href=#editing-command-lines-in-vim>Editing Command Lines In Vim</a></li><li><a href=#adding-text-objects>Adding Text Objects</a></li><li><a href=#surrounding>Surrounding</a></li></ul></li><li><a href=#zsh-plugins>Zsh Plugins</a><ul><li><a href=#zsh-completions>Zsh Completions</a></li><li><a href=#zsh-syntax-highlighting>Zsh Syntax Highlighting</a></li><li><a href=#jumping-to-a-parent-directory-easily>Jumping To A Parent Directory Easily</a></li></ul></li><li><a href=#custom-scripts>Custom Scripts</a></li><li><a href=#external-programs>External Programs</a><ul><li><a href=#multiplex-your-zsh-with-tmux>Multiplex Your Zsh With tmux</a></li><li><a href=#fuzzy-search-with-fzf>Fuzzy Search With fzf</a></li></ul></li><li><a href=#the-z-shell-is-now-yours>The Z-Shell Is Now Yours</a></li></ul></nav></aside><span class=table-of-content-cover></span><header class="main-header post-head no-cover"><a class=blog-title href=https://thevaluable.dev/>The Valuable Dev</a><ul class=header-menu><li><a href=https://thevaluable.dev/page/newsletter><i class="la la-envelope"></i><span class=text>Let's Connect</span></a></li><li><a href=https://thevaluable.dev/page/books><i class="la la-book"></i><span class=text>Books</span></a></li><li><a href=https://thevaluable.dev/page/support><i class="la la-heart-o"></i><span class=text>Support</span></a></li><li><a href=https://thevaluable.dev/page/about><i class="la la-grin-wink"></i><span class=text>About</span></a></li></ul><nav class="page-nav clearfix"><a class=menu-button href=#>&#9776;&nbsp;&nbsp;Menu</a>
<a id=light-button class="light-button icon-button" href=#><i class="la la-moon-o"></i></a>
<a class="tob-button icon-button" href=#><i class="la la-list"></i></a>
<a class="toggle-search icon-button" title=search><i class="la la-search"></i></a></nav></header><aside role=search><a href=# class="close toggle-search"><i class="la la-times-circle"></i></a><div class=search-wrapper><form class=search method=get><input type=search placeholder=search... disabled></form></div><div class="search-results list"></div></aside><main class=content role=main><article class="post post"><header class=post-header><section class=post-meta><div class=li-date><time class=post-date datetime=2020-07-27T00:00:00Z>27 Jul 2020</time>
<span class=time-update>, updated</span>
<time class="post-date time-update" datetime=2022-02-09T00:00:00Z>9 Feb 2022</time>
<a class="la la-twitter" style=font-size:1.4em href="https://twitter.com/share?text=Configuring%20Zsh%20Without%20Dependencies&nbsp;-&nbsp;The%20Valuable%20Dev&url=https%3a%2f%2fthevaluable.dev%2fzsh-install-configure-mouseless%2f" onclick='return window.open(this.href,"twitter-share","width=550,height=235"),!1'><span class=hidden>Twitter</span></a></div><span class="post-tag small"><a href=https://thevaluable.dev/tags/tools/>#Tools</a></span>
<span class="post-tag small"><a href=https://thevaluable.dev/tags/mouseless/>#Mouseless</a></span></section><h1 class=post-title>Configuring Zsh Without Dependencies</h1></header><section class=post-content><picture><source srcset=https://thevaluable.dev/images/2020/zsh/zsh.webp type=image/webp><img width=780 height=520 src=https://thevaluable.dev/images/2020/zsh/zsh.jpg alt="Huey, Dewey, and Louie with a Z, S, and H t-shirt"></picture><p>This article is part of a series about Zsh:</p><div class="notices note"><div class=header><i class="la la-sticky-note-o"></i> Becoming a zsh master</div><div class=body><ol><li><a href=https://thevaluable.dev/zsh-install-configure-mouseless/>Configuring Zsh Without Dependencies</a></li><li><a href=https://thevaluable.dev/zsh-expansion-guide-example/>A Guide to Zsh Expansion with Examples</a></li><li><a href=https://thevaluable.dev/zsh-completion-guide-examples/>A Guide to the Zsh Completion with Examples</a></li><li><a href=https://thevaluable.dev/zsh-line-editor-configuration-mouseless/>A Guide to the Zsh Line Editor with Examples</a></li></ol></div></div><p>There are many boring tasks we repeat day after day: creating, copying, moving or searching files, launching again and again the same tools, docker containers, and whatnot.</p><p>For a developer, the shell is a precious asset which can increase your efficiency over time. It will bring powerful tools at your fingertips, and, more importantly, it will allow you to automate many parts of your workflow.</p><p>To leverage these functionalities, you&rsquo;ll need a powerful and flexible shell. Today, I would like to present your next best friend: the Z shell, or Zsh.</p><p>If you look at the documentation (around 450 pages for the <a href=http://zsh.sourceforge.net/Doc/zsh_a4.pdf target=_blank rel=noopener>PDF version</a>), Zsh can feel daunting. There are so many options available, it can be difficult to come up with a basic configuration you can build upon.</p><p>We&rsquo;ll build, in this article, a basic Zsh config. I&rsquo;ll explain the meaning of (almost) everything along the way, including:</p><ul><li>What&rsquo;s a Unix shell.</li><li>Why Zsh is a good choice.</li><li>How to install Zsh.</li><li>A brief overview of:<ul><li>Useful environment variables.</li><li>Aliases.</li><li>The Zsh options.</li><li>The Zsh completion.</li><li>The Zsh prompt.</li><li>The Zsh directory stack.</li></ul></li><li>How to configure Zsh to make it Vim-like.</li><li>How to add external plugins to Zsh.</li><li>External programs you can use to improve your Zsh experience.</li></ul><p>Are your keyboard ready? Are you fingers warm? Did you stretch your arms? Let&rsquo;s begin, then!</p><h2 id=brief-unix-shell-overview>Brief Unix Shell Overview</h2><p>A shell <em>interpret</em> command lines. You can type them using a prompt in an <em>interactive shell</em>, or you can run shell scripts using a <em>non-interactive shell</em>.</p><p>The shell run just after you logged in with your user. You can imagine the shell as the layer directly above the kernel of Unix-based operating systems (including Linux). Here&rsquo;s the charismatic <a href="https://youtu.be/tc4ROCJYbm0?t=248" target=_blank rel=noopener>Brian Kernighan explaining it casually with his feet on a table</a>.</p><p>When you use a graphical interface (or GUI), you click around with your mouse to perform tasks. When you use a shell, you use plain text instead.</p><p>If you use a graphical interface (like a windows manager or a desktop environment), you&rsquo;ll need a <em>terminal emulator</em> to access the shell. In the old days, a <a href=https://en.wikipedia.org/wiki/Computer_terminal target=_blank rel=noopener>terminal was a real device</a>. Nowadays, it&rsquo;s a program.</p><p>The shell gives you access to many powerful programs. They are called CLIs, or Command Line Interfaces.</p><p>At that point, you might wonder: why using a shell, instead of a graphical interface?</p><ul><li>It&rsquo;s difficult to get a graphical interface right, especially if your software has many functionalities. It can be simpler to build a CLI to avoid some complexity.</li><li>CLIs are usually faster.</li><li>A developer deals often with plain text. CLIs are great for that.</li><li>Many shells, like Linux shells, allow you to pipe CLIs together in order to create a powerful transformation flow.</li><li>It&rsquo;s easier to automate textual commands rather than actions on a graphical interface.</li></ul><blockquote><p>Play around with your command shell, and you&rsquo;ll be surprised at how much more productive it makes you.</p><footer><strong>The Pragmatic Programmer</strong></footer></blockquote><p>A shell is the keystone of a Mouseless Development Environment, and the most powerful tool you can use as a developer.</p><div class="notices note"><div class=header><i class="la la-sticky-note-o"></i> Speaking of which...</div><div class=body>If you want to build a complete Mouseless Development Environment, <a href=https://themouseless.dev/ target=_blank rel=noopener>you might be interested by this book</a>.</div></div><h2 id=bash-vs-zsh>Bash vs Zsh</h2><p>There are other Linux shells available out there, including the famous <a href=https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29 target=_blank rel=noopener>Bash</a>. Why using Zsh?</p><ul><li>The level of flexibility and customization of Zsh is crazy.</li><li>You have access to a powerful completion for your favorite CLIs.</li><li>The Vi mode is golden for every Vim lovers.</li><li>There is an important and active community around Zsh.</li><li>Bash scripts are (mostly) compatible with Zsh.</li></ul><p>Bash is simpler than Zsh, but it has also less functionalities.</p><h2 id=zsh-without-oh-my-zsh>Zsh Without oh-my-zsh</h2><p>You&rsquo;ll see many advising you to install a Zsh framework with a crazy number of plugins, options, aliases, all already configured. The famous ones are <a href=https://ohmyz.sh/ target=_blank rel=noopener>Oh My Zsh</a> and <a href=https://github.com/sorin-ionescu/prezto target=_blank rel=noopener>prezto</a>.</p><p>I tried this approach for years and I think the drawbacks outweigh the benefits:</p><ul><li>I have no clue what&rsquo;s included in these frameworks. When I read their documentations, I can&rsquo;t possibly remember everything it sets. Therefore, I barely use 10% of the functionalities.</li><li>Zsh has already many functionalities and options, it&rsquo;s even more daunting to have a framework on top.</li><li>A framework is a big external dependency which brings more complexity. If there is a conflict with my own configuration or a bug, it can take a long time to figure out what&rsquo;s happening.</li><li>A framework impose rules and way of doing I don&rsquo;t necessarily want, or need.</li></ul><p>Don&rsquo;t get me wrong: these frameworks are incredible feats. They can be useful to get some inspiration for your own configuration. But I wouldn&rsquo;t use them directly.</p><h2 id=let-the-party-begin>Let The Party Begin</h2><p>We&rsquo;ll now configure Zsh. If the files or folders I&rsquo;m speaking about don&rsquo;t exist, you need to create them.</p><p>This configuration was tested with a Linux based system. I have no idea about macOS, but it should work.</p><h3 id=installing-zsh>Installing Zsh</h3><p>You can install Zsh like everything else:</p><ul><li>Debian / Ubuntu: <code>sudo apt install zsh</code></li><li>Red Hat: <code>sudo yum install zsh</code></li><li>Arch Linux: <code>sudo pacman -S zsh</code></li><li>macOS (with brew): <code>brew install zsh</code></li></ul><p>Then, run it in a terminal by typing <code>zsh</code>.</p><h3 id=zsh-config-files>Zsh Config Files</h3><p>To configure Zsh for your user&rsquo;s session, you can use the following files:</p><ul><li><code>$ZDOTDIR/.zshenv</code></li><li><code>$ZDOTDIR/.zprofile</code></li><li><code>$ZDOTDIR/.zshrc</code></li><li><code>$ZDOTDIR/.zlogin</code></li><li><code>$ZDOTDIR/.zlogout</code></li></ul><p>In case you wonder what <code>$ZDOTDIR</code> stands for, we&rsquo;ll come back to it soon.</p><p>Zsh read these files in the following order:</p><ol><li><code>.zshenv</code> - Should only contain user&rsquo;s environment variables.</li><li><code>.zprofile</code> - Can be used to execute commands just after logging in.</li><li><code>.zshrc</code> - Should be used for the shell configuration and for executing commands.</li><li><code>.zlogin</code> - Same purpose than <code>.zprofile</code>, but read just after <code>.zshrc</code>.</li><li><code>.zlogout</code> - Can be used to execute commands when a shell exit.</li></ol><p>We&rsquo;ll use only <code>.zshenv</code> and <code>.zshrc</code> in this article.</p><h3 id=zsh-config-path>Zsh Config Path</h3><p>By default, Zsh will try to find the user&rsquo;s configuration files in the <code>$HOME</code> directory. You can change it by setting the environment variable <code>$ZDOTDIR</code>.</p><p>Personally, I like to have all my configuration files in <code>$HOME/.config</code>. To do so:</p><ol><li>I set the variable <code>$XDG_CONFIG_HOME</code> as following: <code>export XDG_CONFIG_HOME="$HOME/.config"</code>.</li><li>I set the environment variable <code>$ZDOTDIR</code>: <code>export ZDOTDIR="$XDG_CONFIG_HOME/zsh"</code>.</li><li>I put the file <code>.zshrc</code> in the <code>$ZDOTDIR</code> directory.</li></ol><p>Most software will use the path in <code>$XDG_CONFIG_HOME</code> to install their own config files. As a result, you&rsquo;ll have a clean <code>$HOME</code> directory.</p><p>Unfortunately, the file <code>.zshenv</code> <strong>needs to be in your home directory</strong>. It&rsquo;s where you&rsquo;ll set <code>$ZDOTDIR</code>. Then, every file read after <code>.zshenv</code> can go into your <code>$ZDOTDIR</code> directory.</p><h2 id=zsh-basic-config>Zsh Basic Config</h2><h3 id=environment-variables>Environment Variables</h3><p>As we saw, you can set the environment variables you need for your user&rsquo;s session in the file <code>$HOME/.zshenv</code>. This file should only define environment variables.</p><p>For example, you can set up the <a href=https://wiki.archlinux.org/index.php/XDG_Base_Directory target=_blank rel=noopener>XDG Base directory</a> there, as seen above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nb>export</span> <span class=nv>XDG_CONFIG_HOME</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$HOME</span><span class=s2>/.config&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>XDG_DATA_HOME</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$XDG_CONFIG_HOME</span><span class=s2>/local/share&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>XDG_CACHE_HOME</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$XDG_CONFIG_HOME</span><span class=s2>/cache&#34;</span>
</span></span></code></pre></div><p>You can also make sure that any program requiring a text editor use your favorite one:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nb>export</span> <span class=nv>EDITOR</span><span class=o>=</span><span class=s2>&#34;nvim&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>VISUAL</span><span class=o>=</span><span class=s2>&#34;nvim&#34;</span>
</span></span></code></pre></div><p>You can set some Zsh environment variables, too:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nb>export</span> <span class=nv>ZDOTDIR</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$XDG_CONFIG_HOME</span><span class=s2>/zsh&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>HISTFILE</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$ZDOTDIR</span><span class=s2>/.zhistory&#34;</span>    <span class=c1># History filepath</span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>HISTSIZE</span><span class=o>=</span><span class=m>10000</span>                   <span class=c1># Maximum events for internal history</span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>SAVEHIST</span><span class=o>=</span><span class=m>10000</span>                   <span class=c1># Maximum events in history file</span>
</span></span></code></pre></div><p>I already explained the first line. For the other ones, they will:</p><ul><li>Store your command line history in the file <code>.zhistory</code>.</li><li>Allows you to have a history of 10000 entries maximum.</li></ul><p><a href=https://github.com/Phantas0s/.dotfiles/blob/master/zsh/zshenv target=_blank rel=noopener>Here&rsquo;s my .zshenv file</a>, if you need some inspiration.</p><h3 id=aliases>Aliases</h3><p>Aliases are crucial to improve your efficiency. For example, I have a bunch of aliases for git I use all the time. It&rsquo;s always easier to type when it&rsquo;s shorter:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gs</span><span class=o>=</span><span class=s1>&#39;git status&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>ga</span><span class=o>=</span><span class=s1>&#39;git add&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gp</span><span class=o>=</span><span class=s1>&#39;git push&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gpo</span><span class=o>=</span><span class=s1>&#39;git push origin&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gtd</span><span class=o>=</span><span class=s1>&#39;git tag --delete&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gtdr</span><span class=o>=</span><span class=s1>&#39;git tag --delete origin&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gr</span><span class=o>=</span><span class=s1>&#39;git branch -r&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gplo</span><span class=o>=</span><span class=s1>&#39;git pull origin&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gb</span><span class=o>=</span><span class=s1>&#39;git branch &#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gc</span><span class=o>=</span><span class=s1>&#39;git commit&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gd</span><span class=o>=</span><span class=s1>&#39;git diff&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gco</span><span class=o>=</span><span class=s1>&#39;git checkout &#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gl</span><span class=o>=</span><span class=s1>&#39;git log&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>gr</span><span class=o>=</span><span class=s1>&#39;git remote&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>grs</span><span class=o>=</span><span class=s1>&#39;git remote show&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>glo</span><span class=o>=</span><span class=s1>&#39;git log --pretty=&#34;oneline&#34;&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>glol</span><span class=o>=</span><span class=s1>&#39;git log --graph --oneline --decorate&#39;</span>
</span></span></code></pre></div><p>I like to have my aliases in one separate file (called, surprisingly, <code>aliases</code>), and I source it in my <code>.zshrc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nb>source</span> /path/to/my/aliases
</span></span></code></pre></div><p>Here are <a href=https://github.com/Phantas0s/.dotfiles/blob/master/aliases/aliases target=_blank rel=noopener>all my aliases</a>.</p><h3 id=zsh-options>Zsh Options</h3><p>You can set or unset many <a href=http://zsh.sourceforge.net/Doc/Release/Options.html target=_blank rel=noopener>Zsh options</a> using <code>setopt</code> or <code>unsetopt</code>. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>setopt HIST_SAVE_NO_DUPS         <span class=c1># Do not write a duplicate event to the history file.</span>
</span></span><span class=line><span class=cl>unsetopt HIST_SAVE_NO_DUPS       <span class=c1># Write a duplicate event to the history file</span>
</span></span></code></pre></div><p>You can already do a lot of customization only using these options.</p><h3 id=zsh-completion-system>Zsh Completion System</h3><p>The completion system of Zsh is one of its bigger strength, compared to other shells.</p><p>To initialize the completion for the current Zsh session, you&rsquo;ll need to call the function <code>compinit</code>. More precisely, you&rsquo;ll need to add this in your <code>zshrc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>autoload -U compinit<span class=p>;</span> compinit
</span></span></code></pre></div><p>What does it mean?</p><p>The <code>autoload</code> command load a file containing shell commands. To find this file, Zsh will look in the directories of the <em>Zsh file search path</em>, defined in the variable <code>$fpath</code>, and search a file called <code>compinit</code>.</p><p>When <code>compinit</code> is found, its content will be loaded as a <em>function</em>. The function name will be the name of the file. You can then call this function like any other shell function.</p><div class="notices tip"><div class=header><i class="la la-gittip"></i> Tip</div><div class=body>What about the semi-colon <code>;</code>? It&rsquo;s just a handy way to separate commands. It&rsquo;s the same as calling <code>compinit</code> on a new line.</div></div><p>Why using autoload, and not sourcing the file by doing <code>source ~/path/of/compinit</code>?</p><ul><li>It avoids name conflicts if you have an executable with the same name.</li><li>It doesn&rsquo;t expand aliases thanks to the <code>-U</code> option.</li><li>It will load the function only when it&rsquo;s needed (lazy-loading). It comes in handy to speed up Zsh startup.</li></ul><p>Then, let&rsquo;s add the following;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nv>_comp_options</span><span class=o>+=(</span>globdots<span class=o>)</span> <span class=c1># With hidden files</span>
</span></span><span class=line><span class=cl><span class=nb>source</span> /my/path/to/zsh/completion.zsh
</span></span></code></pre></div><p>The first line will complete <a href=https://wiki.archlinux.org/index.php/Dotfiles target=_blank rel=noopener>dotfiles</a>.</p><p>The second line source <a href=https://github.com/Phantas0s/.dotfiles/blob/master/zsh/completion.zsh target=_blank rel=noopener>this file</a>. It&rsquo;s my personal config for the Zsh completion. I&rsquo;ve written an <a href=https://thevaluable.dev/zsh-completion-guide-examples/>article about that</a> if you&rsquo;re interested to dive more into the completion system.</p><p>Now, the completion should work:</p><ul><li>If you type <code>cp</code> and hit the tab key, you&rsquo;ll see that Zsh will complete the command.</li><li>If you type <code>cp -</code> and hit the tab key, Zsh will display the possible arguments for the command.</li></ul><picture><source srcset=https://thevaluable.dev/images/2020/zsh/auto_complete.webp type=image/webp><img width=780 height=520 src=https://thevaluable.dev/images/2020/zsh/auto_complete.png alt="Zsh completion in action"></picture><h3 id=pimp-my-zsh-prompt>Pimp My Zsh Prompt</h3><p>What would be the shell experience without a nice prompt? Dull. Tasteless. Depressing.</p><p>Let&rsquo;s be honest here: Zsh default prompt is ugly. We need to change it, before our eyes start crying some blood. My needs are simple:</p><ul><li>The prompt needs to be on one line. I had display problems with two lines.</li><li>The prompt needs to display some git info when necessary.</li></ul><p>From there, I created <a href=https://github.com/Phantas0s/purification/blob/master/prompt_purification_setup target=_blank rel=noopener>my own prompt</a> from <a href=https://github.com/therealklanni/purity target=_blank rel=noopener>another one</a>. It looks like that:</p><picture><source srcset=https://thevaluable.dev/images/2020/zsh/prompt.webp type=image/webp><img width=780 height=520 src=https://thevaluable.dev/images/2020/zsh/prompt.png alt="Zsh prompt"></picture><p>If you open the prompt script, you&rsquo;ll see that it&rsquo;s pretty simple:</p><ul><li>I set two environment variables: <code>$PROMPT</code> and <code>$RPROMPT</code>. The first one format the left prompt, the second display git information on the far right.</li><li>You can add some formatting styles using, for example, <code>%F{blue}%f</code> to change the color, or <code>%Bmy-cool-prompt%b</code> to make everything bold.</li></ul><p>This prompt doesn&rsquo;t need any external <a href=https://thevaluable.dev/cohesion-coupling-guide-examples/>dependency</a>. You can copy it right away and modify it as much as you want.</p><p><a href=http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html target=_blank rel=noopener>Here&rsquo;s everything you need, to create the prompt of your dream</a>.</p><p>To load the prompt, you need to add something like that in your <code>zshrc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nv>fpath</span><span class=o>=(</span>/my/path/to/zsh/prompt <span class=nv>$fpath</span><span class=o>)</span>
</span></span><span class=line><span class=cl>autoload -Uz name_of_the_prompt_file<span class=p>;</span> name_of_the_prompt_file
</span></span></code></pre></div><p>The first line will add the folder containing the prompt to <code>$fpath</code>, as discussed above. It will also ensure that any function declared in the folder <code>/my/path/to/zsh/prompt</code> will overwrite every other ones with the same name, in other <code>fpath</code> folders.</p><p>The second line autoload the prompt itself.</p><p>This prompt require <a href=https://fontawesome.com/v4.7.0/ target=_blank rel=noopener>font awesome 4</a> for the git icons. You can download the font and install it, or you can change the icons.</p><h3 id=zsh-directory-stack>Zsh Directory Stack</h3><p>Zsh has commands to <a href=http://zsh.sourceforge.net/Intro/intro_6.html target=_blank rel=noopener>push and pop directories on a directory stack</a>.</p><p>By manipulating this stack, you can set up an history of directory visited, and be able to jump back to these directories.</p><p>First, let&rsquo;s set some options in your <code>.zshrc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>setopt AUTO_PUSHD           <span class=c1># Push the current directory visited on the stack.</span>
</span></span><span class=line><span class=cl>setopt PUSHD_IGNORE_DUPS    <span class=c1># Do not store duplicates in the stack.</span>
</span></span><span class=line><span class=cl>setopt PUSHD_SILENT         <span class=c1># Do not print the directory stack after pushd or popd.</span>
</span></span></code></pre></div><p>Then, you can create these aliases:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>d</span><span class=o>=</span><span class=s1>&#39;dirs -v&#39;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> index <span class=o>({</span>1..9<span class=o>})</span> <span class=nb>alias</span> <span class=s2>&#34;</span><span class=nv>$index</span><span class=s2>&#34;</span><span class=o>=</span><span class=s2>&#34;cd +</span><span class=si>${</span><span class=nv>index</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>;</span> <span class=nb>unset</span> index
</span></span></code></pre></div><p>What does it do?</p><ul><li>Every directory visited will populate the stack.</li><li>When you use the alias <code>d</code>, it will display the directories on the stack prefixed with a number.</li><li>The line <code>for index ({1..9}) alias "$index"="cd +${index}"; unset index</code> will create aliases from 1 to 9. They will allow you to jump directly in whatever directory on your stack.</li></ul><p>For example, if you execute <code>1</code> in Zsh, you&rsquo;ll jump to the directory prefixed with <code>1</code> in your stack list.</p><p>You can also increase <code>index ({1..9})</code> to <code>index ({1..100})</code> for example, if you want to be able to jump back to 100 directories.</p><p>For example, you can do that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>~ &gt; <span class=nb>cd</span> .config
</span></span><span class=line><span class=cl>~/.config &gt; <span class=nb>cd</span> devdash
</span></span><span class=line><span class=cl>~/.config/devdash &gt; <span class=nb>cd</span> ..
</span></span><span class=line><span class=cl>~/.config &gt; <span class=nb>cd</span> i3
</span></span><span class=line><span class=cl>~/.config/i3 &gt; <span class=nb>cd</span> ..
</span></span><span class=line><span class=cl>~/.config &gt; d
</span></span><span class=line><span class=cl><span class=m>0</span>       ~/.config
</span></span><span class=line><span class=cl><span class=m>1</span>       ~/.config/i3
</span></span><span class=line><span class=cl><span class=m>2</span>       ~/.config/devdash
</span></span><span class=line><span class=cl><span class=m>3</span>       ~
</span></span><span class=line><span class=cl>~/.config &gt; <span class=m>2</span>
</span></span><span class=line><span class=cl>~/.config/devdash &gt; 
</span></span></code></pre></div><h3 id=zsh-by-default>Zsh By Default</h3><p>When you&rsquo;re ready psychologically to set Zsh as your default shell, you can run these commands:</p><ul><li>For Linux: <code>chsh -s $(which zsh)</code></li><li>For macOS: <code>sudo sh -c "echo $(which zsh) >> /etc/shells" && chsh -s $(which zsh)</code></li></ul><p>A good soul on Reddit whispered me that Zsh is now the default shell from macOS Catalina onwards, so you don&rsquo;t necessarily need the above command.</p><p>Zsh is now part of your life. Congratulation!</p><h2 id=zsh-with-vim-flavors>Zsh With Vim Flavors</h2><p>For editing purposes, <a href=https://thevaluable.dev/phpstorm-vs-vim/>Vim is my best friend</a>. I love when CLIs use some Vim key binding, and Zsh gives you even more than that. If you&rsquo;d like to learn Vim, this <a href=https://thevaluable.dev/vim-commands-beginner/ target=_blank rel=noopener>series of articles</a> can help.</p><h3 id=activating-vi-mode>Activating Vi Mode</h3><p>Zsh has a Vi mode you can enable by adding the following in your <code>.zshrc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>bindkey -v
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>KEYTIMEOUT</span><span class=o>=</span><span class=m>1</span>
</span></span></code></pre></div><p>You can now switch between INSERT and NORMAL mode (called also COMMAND mode) with the <code>ESC</code> key, and use the familiar Vim keystrokes to edit what you&rsquo;re typing in your shell prompt. I write the different modes in uppercase here for clarity, but it doesn&rsquo;t have to be.</p><p>The second line <code>export KEYTIMEOUT=1</code> makes the switch between modes quicker.</p><h3 id=changing-cursor>Changing Cursor</h3><p>A visual indicator to show the current mode (NORMAL or INSERT) could be nice. In Vim, my cursor is a beam <code>|</code> when I&rsquo;m in INSERT mode, and a block <code>█</code> when I&rsquo;m in NORMAL mode. I wanted the same for Zsh.</p><p>You can add the following in your <code>zshrc</code>, or autoload it from a file, <a href=https://github.com/Phantas0s/.dotfiles/blob/master/zsh/plugins/cursor_mode target=_blank rel=noopener>as I did</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>cursor_mode<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1># See https://ttssh2.osdn.jp/manual/4/en/usage/tips/vim.html for cursor shapes</span>
</span></span><span class=line><span class=cl>    <span class=nv>cursor_block</span><span class=o>=</span><span class=s1>&#39;\e[2 q&#39;</span>
</span></span><span class=line><span class=cl>    <span class=nv>cursor_beam</span><span class=o>=</span><span class=s1>&#39;\e[6 q&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>function</span> zle-keymap-select <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>[[</span> <span class=si>${</span><span class=nv>KEYMAP</span><span class=si>}</span> <span class=o>==</span> vicmd <span class=o>]]</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>            <span class=o>[[</span> <span class=nv>$1</span> <span class=o>=</span> <span class=s1>&#39;block&#39;</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=nb>echo</span> -ne <span class=nv>$cursor_block</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=o>[[</span> <span class=si>${</span><span class=nv>KEYMAP</span><span class=si>}</span> <span class=o>==</span> main <span class=o>]]</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>            <span class=o>[[</span> <span class=si>${</span><span class=nv>KEYMAP</span><span class=si>}</span> <span class=o>==</span> viins <span class=o>]]</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>            <span class=o>[[</span> <span class=si>${</span><span class=nv>KEYMAP</span><span class=si>}</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span> <span class=o>]]</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>            <span class=o>[[</span> <span class=nv>$1</span> <span class=o>=</span> <span class=s1>&#39;beam&#39;</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=nb>echo</span> -ne <span class=nv>$cursor_beam</span>
</span></span><span class=line><span class=cl>        <span class=k>fi</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    zle-line-init<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> -ne <span class=nv>$cursor_beam</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    zle -N zle-keymap-select
</span></span><span class=line><span class=cl>    zle -N zle-line-init
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>cursor_mode
</span></span></code></pre></div><p>You can now speak about beams and blocks with passion and verve.</p><h3 id=vim-mapping-for-completion>Vim Mapping For Completion</h3><p>To give Zsh more of a Vim taste, we can set up the keys <code>hjkl</code> to navigate the completion menu.</p><p>First, add the following to your <code>zshrc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>zmodload zsh/complist
</span></span><span class=line><span class=cl>bindkey -M menuselect <span class=s1>&#39;h&#39;</span> vi-backward-char
</span></span><span class=line><span class=cl>bindkey -M menuselect <span class=s1>&#39;k&#39;</span> vi-up-line-or-history
</span></span><span class=line><span class=cl>bindkey -M menuselect <span class=s1>&#39;l&#39;</span> vi-forward-char
</span></span><span class=line><span class=cl>bindkey -M menuselect <span class=s1>&#39;j&#39;</span> vi-down-line-or-history
</span></span></code></pre></div><p>We load here the Zsh module <code>complist</code>. Modules have functionalities which are not part of the Zsh&rsquo;s core, but they can be loaded on demand. <a href=http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html target=_blank rel=noopener>Many different modules are available</a> for your needs.</p><p>Here, the module <code>complist</code> give you access to the keymap <code>menuselect</code>, to customize the menu selection during completion, including how to select what you want.</p><p>In general, the command <code>bindkey -M</code> bind a key to a specific <em>keymap</em>. A keymap is a set of keystrokes bind to specific Zsh functions. In this case, the keymap <code>menuselect</code> bind keystrokes with selecting something in a list.</p><p>To list all the keymaps available (depending on the modules you&rsquo;ve loaded), you can run in your shell <code>bindkey -l</code> (for <code>l</code>ist). You can also <a href=http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Keymaps target=_blank rel=noopener>find the default ones here</a>.</p><p>Last thing: you should always load the module <code>zsh/complist</code> <em>before</em> autoloading <code>compinit</code>.</p><h3 id=editing-command-lines-in-vim>Editing Command Lines In Vim</h3><p>Good news: you can use your favorite editor to edit the commands you&rsquo;re typing in your prompt! Let&rsquo;s add these lines in your <code>.zshrc</code> to do so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>autoload -Uz edit-command-line
</span></span><span class=line><span class=cl>zle -N edit-command-line
</span></span><span class=line><span class=cl>bindkey -M vicmd v edit-command-line
</span></span></code></pre></div><p>Here, we autoload <code>edit-command-line</code>, a function from the module <a href=https://linux.die.net/man/1/zshcontrib target=_blank rel=noopener>zshcontrib</a>, which includes many contributions from Zsh users. This specific function let you edit a command line in your visual editor, defined by the environment variable <code>$VISUAL</code> (or <code>$EDITOR</code>). Great! That&rsquo;s what we wanted.</p><p>We already saw <code>bindkey -M</code>. Using the keymap <code>vicmd</code>, we can bind commands to some NORMAL mode keystrokes. It means that, when you&rsquo;re in NORMAL mode, you can hit <code>v</code> to directly edit your command in your editor.</p><h3 id=adding-text-objects>Adding Text Objects</h3><p>If you use the Vi-mode of Zsh for a while, you&rsquo;ll notice that there are no text objects for quotes or brackets: impossible to do something like <code>da"</code> (to delete a quoted substring) or <code>ci(</code> (to change inside parenthesis). Zsh supports these, you just need to generate and bind them to specific Zsh widgets:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>autoload -Uz <span class=k>select</span>-bracketed <span class=k>select</span>-quoted
</span></span><span class=line><span class=cl>zle -N <span class=k>select</span>-quoted
</span></span><span class=line><span class=cl>zle -N <span class=k>select</span>-bracketed
</span></span><span class=line><span class=cl><span class=k>for</span> km in viopp visual<span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  bindkey -M <span class=nv>$km</span> -- <span class=s1>&#39;-&#39;</span> vi-up-line-or-history
</span></span><span class=line><span class=cl>  <span class=k>for</span> c in <span class=o>{</span>a,i<span class=o>}</span><span class=si>${</span><span class=p>(s..)^</span><span class=k>:-</span><span class=se>\&#39;\&#34;\`\|</span><span class=p>,./:;=+@</span><span class=si>}</span><span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    bindkey -M <span class=nv>$km</span> <span class=nv>$c</span> <span class=k>select</span>-quoted
</span></span><span class=line><span class=cl>  <span class=k>done</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> c in <span class=o>{</span>a,i<span class=o>}</span><span class=si>${</span><span class=p>(s..)^</span><span class=k>:-</span><span class=s1>&#39;()[]{}&lt;&gt;bB&#39;</span><span class=si>}</span><span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    bindkey -M <span class=nv>$km</span> <span class=nv>$c</span> <span class=k>select</span>-bracketed
</span></span><span class=line><span class=cl>  <span class=k>done</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>If you want to know more about Zsh widgets, I&rsquo;ve <a href=https://thevaluable.dev/zsh-line-editor-configuration-mouseless/>written another article about that</a>, where I also explain the code above.</p><h3 id=surrounding>Surrounding</h3><p>Zsh also allows us to mimic the famous <a href=https://github.com/tpope/vim-surround target=_blank rel=noopener>Tim Pope&rsquo;s surround plugin</a>. Just add the following to your <code>zshrc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>autoload -Uz surround
</span></span><span class=line><span class=cl>zle -N delete-surround surround
</span></span><span class=line><span class=cl>zle -N add-surround surround
</span></span><span class=line><span class=cl>zle -N change-surround surround
</span></span><span class=line><span class=cl>bindkey -M vicmd cs change-surround
</span></span><span class=line><span class=cl>bindkey -M vicmd ds delete-surround
</span></span><span class=line><span class=cl>bindkey -M vicmd ys add-surround
</span></span><span class=line><span class=cl>bindkey -M visual S add-surround
</span></span></code></pre></div><p>You can then use <code>cs</code> (change surrounding), <code>ds</code> (delete surrounding), <code>ys</code> (add surrounding) in Zsh&rsquo;s NORMAL mode.</p><h2 id=zsh-plugins>Zsh Plugins</h2><p>The term &ldquo;plugin&rdquo;, as I use it, has nothing official. People often speak about Zsh plugins as external pieces of configuration you can add to your own.</p><p>There are many of these plugins available for Zsh. Many of them are part of Zsh frameworks.</p><h3 id=zsh-completions>Zsh Completions</h3><p>By default, Zsh can complete already many popular CLIs like <code>cd</code>, <code>cp</code>, <code>git</code>, and so on.</p><p>The plugin <a href=https://github.com/zsh-users/zsh-completions target=_blank rel=noopener>zsh-completions</a> add even more completions. The <a href=https://github.com/zsh-users/zsh-completions/tree/master/src target=_blank rel=noopener>list of the newly supported CLIs is here</a></p><p>If you don&rsquo;t use any of the program listed, you don&rsquo;t need this plugin.</p><p>I added <code>zsh-completion</code> as a <a href=https://github.com/Phantas0s/.dotfiles/blob/master/.gitmodules target=_blank rel=noopener>git submodule in my dotfiles</a>. Then, you can automatically add every completion to your <code>fpath</code>, in your zshrc:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nv>fpath</span><span class=o>=(</span>/path/to/my/zsh/plugins/zsh-completions/src <span class=nv>$fpath</span><span class=o>)</span>
</span></span></code></pre></div><p>You don&rsquo;t need to load every completion file, one by one. If you look at the beginning of one of these files, you&rsquo;ll see <code>compdef</code>. It&rsquo;s a function from Zsh which load automagically the completion when it&rsquo;s needed. The completion file itself only needs to be included in your <code>fpath</code>.</p><p>You can also cherry-pick the specific completions you want.</p><h3 id=zsh-syntax-highlighting>Zsh Syntax Highlighting</h3><p>What about syntax highlighting in Zsh? That&rsquo;s what <a href=https://github.com/zsh-users/zsh-syntax-highlighting target=_blank rel=noopener>zsh-syntax-highlighting</a> is about.</p><p>You can source it directly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl><span class=nb>source</span> /path/to/my/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
</span></span></code></pre></div><p>There is one minor downside however: it seems to be currently incompatible with the surround widget we&rsquo;ve seen above. If you want to use both, you need to use the branch <a href=https://github.com/zsh-users/zsh-syntax-highlighting/tree/feature/redrawhook target=_blank rel=noopener>feature/redrawhook</a>.</p><p>You should source this plugin at the bottom of your <code>zshrc</code>. Everything loaded before will then be able to use syntax highlighting if needed.</p><h3 id=jumping-to-a-parent-directory-easily>Jumping To A Parent Directory Easily</h3><p>Do you like to type <code>cd ../../..</code> to come back to the great-grand-parent of the current folder?</p><p>Me neither.</p><p>It&rsquo;s where <a href=https://github.com/Tarrasch/zsh-bd target=_blank rel=noopener>bd</a> can help you. Imagine that you&rsquo;re in the folder <code>~/a/b/c/d</code>. You can jump directly to <code>a</code> with the command <code>bd a</code>.</p><p>The Zsh completion is even included. Awesomeness!</p><p>To use it, you need to source the file <a href=https://github.com/Tarrasch/zsh-bd/blob/master/bd.zsh target=_blank rel=noopener>bd.zsh</a>.</p><h2 id=custom-scripts>Custom Scripts</h2><p>Using a shell allows you to automate many parts of your workflow with shell scripts. That&rsquo;s a huge benefit you should take advantage of.</p><p>I keep most of <a href=https://github.com/Phantas0s/.dotfiles/blob/master/zsh/scripts.zsh target=_blank rel=noopener>my scripts in one file</a> and I <a href=https://github.com/Phantas0s/.dotfiles/blob/master/zsh/README.md target=_blank rel=noopener>document them</a> (roughly) for me to remember what&rsquo;s in there, and for others to get inspired.</p><p>I source the functions in my <code>.zshrc</code>, but you could autoload them too.</p><p>While working, ask yourself what tasks you do again and again, to automate them as much as you can. This is the real power of the shell, and it will make your whole workflow more fun.</p><h2 id=external-programs>External Programs</h2><p>A shell without CLIs would be useless. Here are my personal favorites to expand Zsh functionalities.</p><h3 id=multiplex-your-zsh-with-tmux>Multiplex Your Zsh With tmux</h3><p>I&rsquo;ve already <a href=https://thevaluable.dev/tmux-boost-productivity-terminal/>written about tmux here</a>. It&rsquo;s a terminal multiplexer with a tonne of functionalities: you can split your terminal in many windows or panes, synchronize them, and keep your sessions alive even without terminal. You can even extend it with plugins helping you automating your whole shell workflow.</p><h3 id=fuzzy-search-with-fzf>Fuzzy Search With fzf</h3><p>The fuzzy finder <code>fzf</code> is a fast and powerful tool. You can use it to search anything you want, like a file, an entry in your command line history, or a specific git commit message.</p><p>I wrote (or copied and pasted) a bunch of <a href=https://github.com/Phantas0s/.dotfiles/blob/master/zsh/scripts_fzf.zsh target=_blank rel=noopener>scripts using zsh</a> too, to search through git logs or <code>tmuxp</code> projects.</p><p>There are different ways to install <code>fzf</code>. You&rsquo;ll need first the executable. Then, I would recommend sourcing the files:</p><ul><li><code>key-bindings.zsh</code>, which will include some practical keystrokes like <code>Ctrl-h</code> or <code>Ctrl-t</code></li><li><code>completion.zsh</code>, for <code>fzf</code> completion.</li></ul><p>If you use Arch Linux, you&rsquo;ll need to install the package <code>fzf</code> and simply source these two files in your <code>zshrc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>source</span> /usr/share/fzf/completion.zsh
</span></span><span class=line><span class=cl><span class=nb>source</span> /usr/share/fzf/key-bindings.zsh
</span></span></code></pre></div><p>Otherwise, you&rsquo;ll need to follow the installation process from fzf&rsquo;s README file.</p><h2 id=the-z-shell-is-now-yours>The Z-Shell Is Now Yours</h2><p>You should now have a clean and lean Zsh configuration, and you should understand enough of it to customize it.</p><p>What did we learn with this article?</p><ul><li>Zsh reads its configuration files in a precise order.</li><li>You can set (or unset) many Zsh options depending on your needs.</li><li>The completion system of Zsh is one of its best feature.</li><li>Zsh directory stack allow you to jump easily in directories you&rsquo;ve already visited.</li><li>If you like Vim, Zsh allows you to use keystrokes from the Vim world. You can even edit your commands directly in Vim.</li><li>External plugins can be found on The Internet, to improve even further the Zsh experience.</li><li>You should go crazy on shell scripting, to automate your workflow as much as you can.</li><li>External programs can enhance your experience with the shell, like <code>tmux</code> or <code>fzf</code>.</li></ul><p>All your colleagues will be jealous. Guaranteed.</p><div class=related-sources><div class=h2>Related Sources</div><ul><li><a href=http://zsh.sourceforge.net/ target=_blank rel=noopener>Zsh official documentation</a></li><li><a href=http://zsh.sourceforge.net/FAQ/ target=_blank rel=noopener>Zsh FAQ</a></li><li><a href=https://project-awesome.org/unixorn/awesome-zsh-plugins target=_blank rel=noopener>Awesome Zsh plugins</a></li><li><a href=https://htr3n.github.io/2018/07/faster-zsh/ target=_blank rel=noopener>Profiling Zsh</a></li><li><a href=https://grml.org/zsh/zsh-lovers.html target=_blank rel=noopener>Zsh Lovers</a></li></ul></div></section><footer class=post-footer><section class=newsletter><form action=https://buttondown.email/api/emails/embed-subscribe/thevaluabledev method=post target=popupwindow onsubmit='window.open("https://buttondown.email/thevaluabledev","popupwindow")' class=embeddable-buttondown-form><h3>Let's Connect</h3><p><label for=bd-email>You'll receive <b>each month</b> the last article with additional resources and updates.</label></p><input type=email name=email placeholder=your-email@example.com id=bd-email>
<input type=hidden value=1 name=embed></input>
<input type=submit value="I want more!"></input><p><a target=_blank title="Show me your newsletter!" href=https://buttondown.email/thevaluabledev/archive/the-valuable-dev-new-article-about-vim-and-many/>Here's how it looks</a></p><p>You can reply to any email if you have questions, problems, or feedback. I'll write back as soon as I can.</p></form></form></section><div class="h3 remark42">Share Your Knowledge</div><div id=remark42></div><script>for(var remark_config={host:"https://remark42.thevaluable.dev",site_id:"jadzD9w1sijz",components:["embed"],max_shown_comments:10},buttons=document.getElementsByClassName("light-button"),i=0;i<buttons.length;i++)buttons[i].addEventListener("click",()=>{let e=window.localStorage.getItem("theme");(e==null||e=="light")&&window.REMARK42!=void 0&&window.REMARK42.changeTheme("dark"),e=="dark"&&window.REMARK42!=void 0&&window.REMARK42.changeTheme("light")});(function(e){for(t=0;t<e.length;t++){var t,n=document,s=n.createElement("script");s.src=remark_config.host+"/web/"+e[t]+".js",s.defer=!0,window.addEventListener("scroll",function(){var e=window.localStorage.getItem("theme");e==null||e=="light"?remark_config.theme="light":remark_config.theme="dark",(n.head||n.body).appendChild(s)},{once:!0})}})(remark_config.components||["embed"])</script></footer></article></main><aside class=read-next id=read-next><a class=read-next-story style=background-image:url(/images/2022/zle/zle.webp) href=https://thevaluable.dev/zsh-line-editor-configuration-mouseless/><section class=post><h2>A Guide to the Zsh Line Editor with Examples</h2></section></a><a class="read-next-story prev" style=background-image:url(/images/2023/fzf-guide/gandalf-fuzzy-search-ring.webp) href=https://thevaluable.dev/practical-guide-fzf-example/><section class=post><h2>A Practical Guide to fzf: Building a File Explorer</h2></section></a></aside><footer class=site-footer><section class=copyright><a href>The Valuable Dev</a> All right reserved - 2021</section><section class=social><a class=bloglogo href=https://thevaluable.dev/page/newsletter target=_blank><span class="la la-envelope"></span></a>
&nbsp;
<a class=bloglogo href=https://github.com/phantas0s target=_blank><span class="la la-github"></span></a>
&nbsp;
<a class=bloglogo href=https://youtube.com/channel/UCoJtk2M8bme9KXTe6F3K-Yg target=_blank><span class="la la-youtube"></span></a>
&nbsp;
<a class=bloglogo href=https://twitter.com/Cneude_Matthieu target=_blank><span class="la la-twitter"></span></a>
&nbsp;
<a class=bloglogo href=https://www.linkedin.com/in/matthieu-cneude-28038182 target=_blank><span class="la la-linkedin"></span></a>
&nbsp;
<a class=bloglogo href=https://thevaluable.dev/index.xml target=blank><span class="la la-feed"></span></a></section><section class=poweredby>Proudly generated by <a class=icon-hugo href=http://gohugo.io>HUGO</a></section></footer></div><link rel=stylesheet href=https://maxst.icons8.com/vue-static/landings/line-awesome/line-awesome/1.3.0/css/line-awesome.min.css media=none onload='this.media="screen"'><script type=text/javascript src=https://thevaluable.dev/app.881bf33056625cefe0a3d47b272cef91c09a8403aed71fcc0bb589a2e3b23d3a.js integrity="sha256-iBvzMFZiXO/go9R7JyzvkcCahAOu1x/MC7WJouOyPTo=" media=screen></script></body></html>