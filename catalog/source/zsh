#! /usr/bin/env sh

###            _
###    _______| |__  _ __ ___
###   |_  / __| '_ \| '__/ __|
###  _ / /\__ \ | | | | | (__
### (_)___|___/_| |_|_|  \___|
###
###
###  # # # # # #
###       #
###  # # # # # #
###

: '
.zshrc
zsh runcom configuration
copyright (c) 2019 - 2024  |  oxo

----------------------------------------------------------------------
GNU GPLv3 GENERAL PUBLIC LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
https://www.gnu.org/licenses/gpl-3.0.txt

@oxo@qoto.org
======================================================================

# dependencies
  base16-shell, fd, fzf, git
  $XDG_CONFIG_HOME/i3blocks
  $XDG_CONFIG_HOME/sway
  $XDG_CONFIG_HOME/zsh/alia
  $XDG_CONFIG_HOME/zsh/completions
  $XDG_CONFIG_HOME/source/text_appearance
  /usr/share/zsh/plugins/zsh-syntax-highlighting

# usage
  n/a

# examples
  n/a

# '


cfg="$XDG_CONFIG_HOME"
zsh_config="$cfg/zsh"
zsh_function="$zsh_config/function"

## decentralized configuration
for sh_function in $zsh_function/*.sh; do

    source $sh_function

done
#! /usr/bin/env sh

# --------------------------------------------------------------------
# 01-sourcing.sh


# sourcing

## file pointers
fzf_tab="$cfg/fzf-tab/fzf-tab.zsh"
fzf_zsh="$cfg/fzf/.fzf.zsh"
text_appearance="$cfg/source/text_appearance"
zsh_alia="$zsh_config/alia"
zsh_completions="$zsh_config/completions/completion.zsh"
zsh_syntax_hl='/usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh'

## alia
[[ -f $zsh_alia ]] && source $zsh_alia

## text_appearance
[[ -f $text_appearance ]] && source $text_appearance

## zsh completions
[[ -f $zsh_completions ]] && source $zsh_completions
#! /usr/bin/env sh

# --------------------------------------------------------------------
# 02-history.sh


# history settings

hist_cmd_offset=100000

## history shell options
## see man zshoptions (history)

## save timestamp and duration
setopt EXTENDED_HISTORY

## when trimming history file, first trim from duplicate entries
setopt HIST_EXPIRE_DUPS_FIRST

## prefix a command with a space keeps it out of history
setopt HIST_IGNORE_SPACE

## remove superfluous blanks
setopt HIST_REDUCE_BLANKS

## writing options
## WARNING these three options are mutually exclusive
setopt SHARE_HISTORY
#setopt INC_APPEND_HISTORY
#setopt INC_APPEND_HISTORY_TIME
#! /usr/bin/env sh

# --------------------------------------------------------------------
# abs-rel-path-tgl.sh


function abs-rel-path-tgl ()
{
    ## select & kill word on cursor (sets CUTBUFFER)
    zle select-in-blank-word
    zle kill-region

    cursor_path="$CUTBUFFER"

    if [[ -e "$cursor_path" ]]; then
	## existing file, directory or symlink

	if [[ "$cursor_path" =~ ^/ ]]; then
	    ## have absolute path
	    ## set relative path

	    tgl_path=$(realpath --relative-to "$PWD" "$cursor_path")

	else
	    ## have relative path
	    ## set absolute path

	    tgl_path="${cursor_path:A}"
	    #tgl_path=$(realpath "$cursor_path")

	fi

	CUTBUFFER="$tgl_path"

	zle vi-put-before

    else

	## no valid path; do nothing
	CUTBUFFER="$cursor_path"
	zle vi-put-before

    fi
}

zle -N abs-rel-path-tgl
#! /usr/bin/env sh

# --------------------------------------------------------------------
# cd-funcs.sh


function cd-nav-dirs ()
{
    # cd navigate directories with fzf

    unset srch_env_prmt_arr
    unset srch_env_dir_arr
    unset srch_env_naa
    unset fzf_output
    unset fd_path
    unset fzf_prompt

    ## dir names and their fzf_prompts
    declare -A srch_env_prmt_arr
    srch_env_prmt_arr[HOME]='H'
    srch_env_prmt_arr[ROOT]='R'
    srch_env_prmt_arr[CWD]='C'

    ## dir names and their actual dirs
    declare -A srch_env_dir_arr
    srch_env_dir_arr[HOME]=$HOME
    srch_env_dir_arr[ROOT]=$ROOT
    srch_env_dir_arr[CWD]=$PWD

    ## generate dir_stack
    dirstack
    fzf_prompt='S'

    dir_stack_select_fzf=$(printf '%s' "$dir_stack" | fzf --prompt "$fzf_prompt ")

    if [[ -d $dir_stack_select_fzf ]]; then

	## dir_select_fzf is a valid:
	### absolute directory, or
	### child in cwd

	## insert at cursor position
	### insert and keep cursor in place
	#RBUFFER="cd ${dir_select_fzf}${RBUFFER}"
	### insert and move cursor eol
	#LBUFFER+="cd $dir_select_fzf"
	### overwrite entire buffer and keep cursor in place
	#BUFFER="cd $dir_select_fzf"
	### overwrite entire buffer and move cursor eol
	BUFFER="cd $dir_stack_select_fzf"
	zle vi-add-eol

    elif [[ -n $dir_stack_select_fzf ]]; then

	## dir_select_fzf is no valid absolute directory
	## nor from cwd accessible relative directory
	## test if (relative) dir exist somewhere in the filesystem
	fd_path=$ROOT
	fzf_prompt='R'
	fd_pattern="$dir_stack_select_fzf"
	fzf_query="$fd_pattern"

	printf "  acquiring ${(k)srch_env_dir_arr[(r)$fd_path]} data  [ C-c > abort ]\r"

	fd_list_dirs=$(fd --type d --hidden --full-path "$fd_pattern" $fd_path)

	dir_select=$(printf '%s' "$fd_list_dirs" | fzf --prompt "$fzf_prompt " --query "$fzf_query")

	if [[ -d $dir_select ]]; then

	    ## dir_pwd_select is a directory
	    BUFFER="cd ${dir_select}"
	    zle vi-add-eol

	fi

    elif [[ -z $dir_stack_select_fzf ]]; then

	## choose search environment
	fzf_prompt='SRCH_ENV'

	## add cancel option
	srch_env_dir_arr[ZQXIT]='ZQXIT'

	## iterate over associated arr and get all keys
	for srch_env_dir in "${(@k)srch_env_dir_arr}"; do

	    ## make non-associative (naa) array (indexed array)
	    srch_env_naa+=($srch_env_dir)

	done

	## HOME always first
	## of srch_env_naa make first item HOME and
	## sort the rest of the items in the array
	tail_env_dirs=()
	## easier fzf select; need home almost always
	first_dir='HOME'

	## array (tail_env_dirs) without first_dir
	for dir in "${srch_env_naa[@]}"; do

	    if [[ "$dir" != "$first_dir" ]]; then

		tail_env_dirs+=("$dir")

	    fi

	done

	## sort tail_env_dirs array
	IFS=$'\n' tail_env_dirs_sort=($(sort <<< "${tail_env_dirs[@]}"))
	unset IFS

	srch_env_dirs=("$first_dir" "${tail_env_dirs_sort[@]}")

	## one item from srch_env_dirs becomes fd_path_sel
	## PWD, HOME, ROOT, ...
	fd_path_sel=$(printf '%s\n' "${srch_env_dirs[@]}" | fzf --prompt "$fzf_prompt ")

	if [[ -z $fd_path_sel || $fd_path_sel == 'ZQXIT' ]]; then

	    zle reset-prompt

	elif [[ $fd_path_sel == 'PWD' ]]; then

	    cd-child-joint

	else

	    ## HOME or ROOT
	    fd_path=${srch_env_dir_arr[$fd_path_sel]}
	    fzf_prompt=${srch_env_prmt_arr[$fd_path_sel]}
	    fzf_query=$fd_path/

	    ## select a directory under $fd_path
	    fd_list_dirs=$(fd --type d --hidden . $fd_path)

	    dir_select=$(printf '%s' "$fd_list_dirs" | fzf --prompt "$fzf_prompt " --query "$fzf_query")

	    if [[ -d $dir_select ]]; then

		## dir_pwd_select is a directory
		BUFFER="cd ${dir_select}"
		zle vi-add-eol

	    fi

	fi

    fi

    zle -K viins
}

zle -N cd-nav-dirs


function cd-child ()
{
    ## search and select directories from cwd
    ## for drill down; apply for max-level=1
    ## press C-j again for no maximum level (cd-child-joint)

    ## clear command line
    zle kill-line

    ## set variables
    cd_function=1
    fzf_prompt='C'
    fd_path='.'
    fd_options='--max-depth=1'
    #TODO resolve fd error when sending multiple fd_options
    #fd_options='--max-depth 1 --type directory --hidden --follow'  ## fd error
    #fd_path=$PWD  ## fd error
    #fd_options='--max-depth 1'  ## fd error

    ## number of depth 1 subdirs
    #fd_path_no_sub_dirs=$(fd "$fd_options" . $fd_path | wc -l)  ## fd error
    fd_path_no_sub_dirs=$(fd --type directory --hidden --follow $fd_options . $fd_path | wc -l)

    ## directory types; root, bodies and leaves
    if [[ $fd_path_no_sub_dirs -eq 0 ]]; then

	## dir is a leaf (contains no subdirs)
	printf "${fg_amber}@leaf${st_def}"
	sleep 0.5
	zle reset-prompt

    elif [[ $fd_path_no_sub_dirs -ge 1 ]]; then

	## dir is a body (contains subdirs)
	insert-item-fzf $fd_path $fd_options $fzf_prompt

	## place and execute 'cd'
	if [[ -z $fzf_output ]]; then

	    ## empty output (i.e. C-j)
	    cd-child-joint

	elif [[ -n $fzf_output ]]; then

	    BUFFER="cd $BUFFER" && zle accept-line

	    ## reset cd_function
	    cd_function=''

	fi

    fi
}

zle -N cd-child


function cd-child-joint ()
{
    ## search and select directories from cwd and deeper
    ## for drill down; no maximum level

    ## clear command line
    zle kill-line

    ## set variables
    cd_function=1
    fzf_prompt='C'
    fd_path=$PWD
    fd_options='--'

    ## number of subdirs
    fd_path_no_sub_dirs=$(fd --type directory --hidden --follow --max-depth 1 . $fd_path | wc -l)

    ## directory types; root, bodies and leaves
    if [[ $fd_path_no_sub_dirs -eq 0 ]]; then

	## dir is a leaf (contains no subdirs)
	printf "${fg_amber}@leaf${st_def}"
	sleep 0.5
	zle reset-prompt

    elif [[ $fd_path_no_sub_dirs -ge 1 ]]; then

	## dir is a body (contains subdirs)
	insert-item-fzf $fd_path $fd_options $fzf_prompt

	## place and execute 'cd'
	[[ -n $fzf_output ]] && BUFFER="cd $BUFFER" && zle accept-line

    fi

    ## reset cd_function
    cd_function=''
}

zle -N cd-child-joint


function cd-up ()
{
    ## directory types; root, bodies and leaves
    if [ "$(echo $PWD)" = "/" ]; then

	## dir is the root (/)
	printf "${fg_amber}@root${st_def}"
	sleep 0.5
	zle reset-prompt

    else

	## dir is not the root (/)
	## go to parent directory
	BUFFER="cd .."
	zle accept-line

    fi
}

zle -N cd-up


function cd-yazi ()
{
    local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"

    yazi "$@" --cwd-file="$tmp"

    if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then

	BUFFER="cd $cwd"
	#zle accept-line
	zle-line-init

    fi

    rm -f "$tmp"
    #TODO DEV: cursor shape is block
    zle reset-prompt
}

zle -N cd-yazi


function cd-lf ()
{
    ## go to active directory when lf exits

    ## for precmd:
    ## get t0 for $time_exec (ns)
    t0_exec_ns=$(date +'%s%N')

    printf 'cd-lf\n'
    lf_output=$(command lf -print-last-dir "$@")
    #cd $(command lf -print-last-dir "$@")

    ## place and execute 'cd'
    [[ -n $lf_output ]] && BUFFER="cd $lf_output"

    precmd
}

zle -N cd-lf
#! /usr/bin/env sh

# --------------------------------------------------------------------
# chpwd.sh


# pwd, statistics and ls when cwd changes
function chpwd ()
{
    ## update $CWD
    export CWD="$(pwd)"

    ## prompt path color
    if [[ -w $PWD ]]; then

	local left_bar="%F{blue}%B%~%f%b"

    else

	# no write permission directory color
	# spaces are intended
	local left_bar="%F{#000000}%K{#ffbf00}%B %~ %b%k%f"
	# local left_bar="%F{#ffffff}%B %~ %b%f"

    fi

    ## directory count
    d_cnt=$(find . -maxdepth 1 -type d | tail -n +2 | wc -l)
    ## hidden directory count
    dh_cnt=$(find . -maxdepth 1 -type d -name '.*' | tail -n +2 | wc -l)
    ## visible directory count
    dv_cnt=$(( d_cnt - dh_cnt ))

    ## file count
    f_cnt=$(find . -maxdepth 1 -type f | wc -l)
    ## hidden file count
    fh_cnt=$(find . -maxdepth 1 -type f -name '.*' | wc -l)
    ## visible file count
    fv_cnt=$(( f_cnt - fh_cnt ))

    ## symlink count
    l_cnt=$(find . -maxdepth 1 -type l | wc -l)
    ## hidden symlink count
    lh_cnt=$(find . -maxdepth 1 -type l -name '.*' | wc -l)
    ## visible symlink count
    lv_cnt=$(( l_cnt - lh_cnt ))

    ## total item count
    ti_cnt=$(( d_cnt + f_cnt + l_cnt ))

    ## right bar
    ### sigma
    rb1=$(printf "${fg_teal}${st_bold}%s${st_def}" '∑')
    # rb1=$(printf "\e[1;90m∑\e[0m")
    ### total count
    rb2=$(printf "${fg_teal}${st_bold} %s ${st_def}" "$ti_cnt")
    # rb2=$(printf "\e[1;90m $ti_cnt \e[0m")
    ### directories
    rb3=$(printf "\e[1;94;100m $dv_cnt.$dh_cnt \e[0m")
    ### files
    rb4=$(printf "\e[0;39;49m $fv_cnt.$fh_cnt \e[0m")
    ### symlinks
    rb5=$(printf "\e[1;36;100m $lv_cnt.$lh_cnt \e[0m")

    ### synthesized
    right_bar=$(printf $rb1$rb2$rb3$rb4$rb5)

    ## right bar aligned to right edge
    ### position, alignment and correctional parameters
    #local lb_corr=0
    #local rb_corr=-66
    #local lb_length=$(( ${#${(S%%)left_bar//(\%([KF1]|)\{*\}|\%[Bbkf])}} + lb_corr ))
    #local rb_length=$(( ${#${(S%%)right_bar//(\%([KF1]|)\{*\}|\%[Bbkf])}} + rb_corr ))
    #local bar_filler_spaces=$(( COLUMNS - lb_length - rb_length ))
    #print -Pr "$left_bar${(l:$bar_filler_spaces:)}$right_bar"
    ### testing alignment
    #print $COLUMNS $lb_length $bar_filler_spaces $rb_length
    ### end testing alignment

    print -Pr "$left_bar"
    ## right bar without right edge algnment
    print -Pr "$right_bar"
    #print -Pr "$left_bar  $right_bar"

    # NOTICE presume ls alias with eza_wrapper.sh
    ls --almost-all --group-directories-first

    #eza --all --group-directories-first
    #ls -A
}
#! /usr/bin/env sh

# --------------------------------------------------------------------
# cursor.sh



function def-cursor ()
{
    ## define cursor styles
    local style

    case $1 in

        reset )
	    # to default
	    style=0
	    ;;

	block_blink )
	    # default
	    style=1
	    ;;

	block_steady )
	    style=2
	    ;;

	underline_blink )
	    style=3
	    ;;

	underline_steady )
	    style=4
	    ;;

	vertical-line_blink )
	    style=5
	    ;;

	vertical-line_steady )
	    style=6
	    ;;

	* )
	    style=0
	    ;;

    esac

    ### define cursor
    [ $style -ge 0 ] && echo -n "\e[${style} q"
}


function set-cursor ()
{
    ## set cursor styles
    case $KEYMAP in

        main | viins )
	    def-cursor vertical-line_blink
	    ;;

        vicmd )
	    def-cursor block_blink
	    ;;

        visual )
	    def-cursor block_steady
	    ;;

	* )
	    def-cursor underline_blink
	    ;;

    esac
}


function zle-keymap-select ()
{
    ## set_ps1
    set-cursor
    zle reset-prompt
}


function zle-line-init ()
{
    zle -K $DEFAULT_VI_MODE
    ## set_ps1
    set-cursor
    zle reset-prompt
}


function zle-line-finish ()
{
    ## set_ps1
    set-cursor
    zle reset-prompt
}
#! /usr/bin/env sh

# --------------------------------------------------------------------
# decorations.sh


function decorations ()
{
    ## define text style with select & paste
    ## with alacritty this is overridden by [colors.selection]
     zle_highlight=(\
      isearch:fg=#bbbbbb,bg=#000000 \
          region:fg=#000000,bg=#555555 \
          special:fg=#bbbbbb,bg=#000000 \
          suffix:fg=#bbbbbb,bg=#000000 \
          paste:fg=#bbbbbb,bg=#000000
     )


    ## syntax highlighting
    #source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
    [[ -f $zsh_syntax_hl ]] && source $zsh_syntax_hl
}

decorations


function base16-config ()
{
    ## base16-shell colorscheme
    ## https://github.com/chriskempson/base16-shell

    ## source profile_helper
    BASE16_SHELL="$XDG_CONFIG_HOME/base16-shell/"
    [ -n "$PS1" ] && \
	[ -s "$BASE16_SHELL/profile_helper.sh" ] && \
	source "$BASE16_SHELL/profile_helper.sh"
}

base16-config

    ## set base16_shell colorscheme
    base16_irblack
#! /usr/bin/env sh

# --------------------------------------------------------------------
# dir-stack.sh

: '
# NOTICE
dir-stack script > dirstack function > dir_stack variable
# '

function dirstack ()
{
    ## hist_cd: chronological list of unique directories from history
		    #grep --binary-files text '^cd ' | \
    hist_cd=$(\
		sed --regexp-extended 's/^:[[:space:]][[:digit:]]{10}:[[:digit:]]+;//' $HISTFILE | \
		    grep '^cd ' 2>/dev/null | \
		    sed --regexp-extended -e '/cd [\.]{1,2}$/d' -e '/cd -/d' -e 's|\.\./||' -e 's|^cd ||' -e 's|/$||' | \
		    sed "s|^~|$HOME|" | \
		    nl --number-format ln | \
		    sort --key 1,1 --numeric-sort --reverse | \
		    sed "1i 0 $OLDPWD" | \
		    awk '!seen[$2]++ {print $1, $2}' | \
		    awk '!($1="")' | \
		    sed --regexp-extended 's/^[[:space:]]+//' | \
		    grep --binary-files text --invert-match --line-regexp $(basename $PWD) | \
		    grep --binary-files text --invert-match --line-regexp $PWD | \
		    sed '/^\s*$/d'\
	   )

    ## sed extract commands from histfile
    ## grep only cd commands; occasional binary data error message suppressed
    ## sed remove lines with cd .(.), cd -, erase ../, cd[space], and trailing slashes
    ## sed replace ~ with $HOME
    ## nl add linenumbers (for chronological order)
    ## sort chronological
    ## sed insert previous working directory on first line (most recent)
    ## awk only second column unique values (but show both columns)
    ## awk remove linenumbers
    ## sed remove leading spaces
    ## grep remove basename $PWD (can't move to it)
    ## grep remove full $PWD (can't move to it)
    ## sed remove empty lines (trailing backslash is for linebreak)

    ## from hist_cd show only show directories in reach from cwd
    dirs_in_reach_arr=()
    while read hist_cd_line; do

	if [ -d "$hist_cd_line" ]; then

	    dirs_in_reach_arr+=("$hist_cd_line")

	fi

    done <<< "$hist_cd"

    ## directoriies in reach (dir)stack
    dir_stack=$(printf "${fg_blue}${st_bold}%s${st_def}\n" "${dirs_in_reach_arr[@]}")
    #dir_stack=$(printf '%s\n' "${dirs_in_reach_arr[@]}")
}
#! /usr/bin/env sh

# --------------------------------------------------------------------
# foreground.sh


function foreground ()
{
    ## bring background jobs to the foreground
    fg
}

zle -N foreground
#! /usr/bin/env sh

# --------------------------------------------------------------------
# fzf-config.sh


function fzf-config ()
{
    ## https://github.com/junegunn/fzf#installation
    ## WARNING path is modified here
    [[ -f $fzf_zsh ]] && source $fzf_zsh

    # $fzf_zsh
    # sources:
    # $XDG_CONFIG_HOME/fzf/.fzf/shell/key-bindings.zsh
    # which defines keybindings:
    # CTRL-T - Paste the selected file path(s) into the command line
    # ALT-C - cd into the selected directory
    # CTRL-R - Paste the selected command from history into the command line

    # $XDG_CONFIG_HOME/zsh/.zshenv
    # defines:
    # FZF_DEFAULT_OPS environment variable defines fzf default options

    ## fzf-tab
    ## https://github.com/Aloxaf/fzf-tab
    ## WARNING fpath is modified here
    [[ -f $fzf_tab ]] && source $fzf_tab

    ## fzf-tab-completions
    ## https://github.com/lincheney/fzf-tab-completion
    #source $XDG_CONFIG_HOME/fzf-tab-completion/zsh/fzf-zsh-completion.sh
}

fzf-config


#  ## [Ctrl-r for shell history but also bulk select and remove from history · junegunn/fzf · Discussion #3629 · GitHub](https://github.com/junegunn/fzf/discussions/3629)
#  function modified-fzf-history-widget ()
#  {
#      local selected
#      setopt localoptions noglobsubst noposixbuiltins pipefail no_aliases no_bash_rematch 2> /dev/null
#
#      ## appends the current shell history buffer to the HISTFILE
#      builtin fc -AI $HISTFILE
#
#      ## pushes entries from the $HISTFILE onto a stack and uses this history
#      builtin fc -p $HISTFILE $HISTSIZE $SAVEHIST
#
#      selected="$(builtin fc -rl 1 |
#      awk '{ cmd=$0; sub(/^[ \t]*[0-9]+\**[ \t]+/, "", cmd); if (!seen[cmd]++) print $0 }' |
#      FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} ${FZF_DEFAULT_OPTS-} -n2..,.. --scheme=history --bind=ctrl-r:toggle-sort,ctrl-z:ignore ${FZF_CTRL_R_OPTS-} --query=${(qqq)LBUFFER} --multi" $(__fzfcmd))"
#
#      local ret=$?
#      if [[ -n $selected ]]; then
#
#  	if [[ "$selected" =~ ^[[:blank:]]*[[:digit:]]+ ]]; then
#
#  	    builtin fc -pa "$HISTFILE"
#  	    zle vi-fetch-history -n "$MATCH"
#
#  	else # selected is a custom query, not from history
#
#  	    LBUFFER="$selected"
#
#  	fi
#
#      fi
#
#      ## read the history from the history file into the history list
#      builtin fc -R $HISTFILE
#      zle reset-prompt
#      return $ret
#  }
#
#  zle -N modified-fzf-history-widget
#
#
#  export FZF_CTRL_R_OPTS="$(
#  	cat <<'FZF_FTW'
#  --bind "ctrl-d:execute-silent(zsh -ic 'builtin fc -p $HISTFILE $HISTSIZE $SAVEHIST; for i in {+1}; do ignore+=( \"${(b)history[$i]}\" );done;
#  	HISTORY_IGNORE=\"(${(j:|:)ignore})\";builtin fc -W $HISTFILE')+reload:builtin fc -p $HISTFILE $HISTSIZE $SAVEHIST; builtin fc -rl 1 |
#  	awk '{ cmd=$0; sub(/^[ \t]*[0-9]+\**[ \t]+/, \"\", cmd); if (!seen[cmd]++) print $0 }'"
#  --bind 'enter:accept-or-print-query'
#  FZF_FTW
#  )"
#  #--prompt ' Global History > '
#  #--header 'select [RET] remove [C-d]'
#! /usr/bin/env sh

# --------------------------------------------------------------------
# git.sh


function git-branch ()
{
    # Long form
    branch="$(git rev-parse --abbrev-ref HEAD 2> /dev/null)"
    # Short form
    # git rev-parse --abbrev-ref HEAD 2> /dev/null | sed -e 's/.*\/\(.*\)/\1/'

    git_status="$(git status 2> /dev/null)"

    if echo "${git_status}" | grep -c 'working tree clean' > /dev/null 2>&1; then

	## up-to-date branch (default grey)
	print "%F{#bbbbbb}$branch%f"

    else

	## changed branch (amber)
	print "%F{#ffbf00}$branch%f"

    fi
}


function git-dirty ()
{
    ## [Git - git-status Documentation](https://git-scm.com/docs/git-status#_short_format)
    # a ahead
    # b behind
    # c to be committed
    # + new
    # - deleted
    # m modified
    # r renamed
    # ? untracked

    # instead of vcs_info
    # [zsh: 26 User Contributions](https://zsh.sourceforge.io/Doc/Release/User-Contributions.html#vcs_005finfo-Configuration)

    git_status="$(git status 2> /dev/null)"

    if echo "${git_status}" | grep -c 'branch is ahead' > /dev/null 2>&1; then

	ahead=$(git status | grep 'branch is ahead' | awk '{print $8}')
	printf 'a%s ' "$ahead"

    fi

    if echo "${git_status}" | grep -c 'branch is behind' > /dev/null 2>&1; then

	behind=$(git status | grep 'branch is behind' | awk '{print $8}')
	printf 'b%s ' "$behind"

    fi

    if echo "${git_status}" | grep -c 'new file:' > /dev/null 2>&1; then

	new=$(git status --porcelain > /dev/null 2>&1 | grep '^A\|^.A' | wc -l)
	printf "${fg_green}+%s${st_def} " "$new"

    fi

    if echo "${git_status}" | grep -c 'deleted:' > /dev/null 2>&1; then

	deleted=$(git status --porcelain > /dev/null 2>&1 | grep '^D\|^.D' | wc -l)
	printf "${fg_red}-%s${st_def} " "$deleted"

    fi

    if echo "${git_status}" | grep -c 'modified:' > /dev/null 2>&1; then

	modified=$(git status --porcelain > /dev/null 2>&1 | grep '^M\|^ M' | wc -l)
	printf 'm%s ' "$modified"

    fi

    if echo "${git_status}" | grep -c 'renamed:' > /dev/null 2>&1; then

	renamed=$(git status --porcelain > /dev/null 2>&1 | grep '^R\|^.R' | wc -l)
	printf 'r%s ' "$renamed"

    fi

    if echo "${git_status}" | grep -c 'Changes to be committed:' > /dev/null 2>&1; then

	tobeco=$(git diff --cached --numstat | wc -l)
	#tobeco=$(git rev-list --count --all)
	printf "${st_rev}c%s${st_def} " "$tobeco"

    fi

   if echo "${git_status}" | grep -c 'Untracked files:' > /dev/null 2>&1; then

	untracked=$(git status --porcelain > /dev/null 2>&1 | grep '^??' | wc -l)
	printf "${bg_red}${fg_black}?%s${st_def} " "$untracked"

    fi
}


function git-add-commit ()
{
    BUFFER="git add . && git commit --gpg-sign="$GPG_SIGN" -a -m '$(printf '%s_%X (local_update)\n' "$(date +%Y%m%d_%H%M%S)" "$(date +%s)")'"
    zle end-of-line
}

zle -N git-add-commit
#! /usr/bin/env sh

# --------------------------------------------------------------------
# insert-item-fzf.sh


function insert-item-fzf ()
{
    ## fzf insert file- or directory-paths on command line

    fd_path="$1"
    fd_options="$2"
    fzf_prompt="$3"
    fzf_query="$4"

    # fzf query fd search
    case $cd_function in

	1 )
	    ## cd-*-functions enter here (i.e. cd-child)

	    if [[ $fd_path_no_sub_dirs -eq 1 ]]; then

		## cwd has only one subdir
		#fzf_output="$(fd --color never $fd_options . $fd_path)"
		fzf_output="$(fd --color never --type directory --hidden --follow --max-depth 1 . $fd_path)"

	    else

		## if value is '--'; reset fd_options
		[[ $fd_options == '--' ]] && fd_options=''

		## all directories in fd_path
		fd_list_dirs=$(fd --type directory --hidden --follow $fd_options . $fd_path)

		## in this block fzf has no multi selection
		## :abort for cd-child to enter cd-child-joint (pressing C-j twice)
		dir_select=$(printf '%s' "$fd_list_dirs" | fzf --prompt "$fzf_prompt " --query "$fzf_query" --bind ctrl-j:abort)

		fzf_output=$dir_select

	    fi
	    ;;

	* )
	    ## in this block fzf has multi selection
	    if [[ -n $dir_stack ]]; then

		fd_list_items=$dir_stack

	    elif [[ -n $fd_path ]]; then

		## this can take a while, so we give some user feedback
		printf '%s %s .. retrieving file data' "$fzf_prompt" "$fd_path"

		## all files and directories in fd_path
		fd_list_items=$(fd --hidden . $fd_path)

	    fi

	    ## erase line
	    printf "\r"; tput el

	    ## in this block fzf has multi selection
	    ## tr converts multiple fzf entries to one line
	    ## sed remove trailing space
	    fzf_output=$(printf '%s' "$fd_list_items" | \
			     fzf --multi --ansi --prompt="$fzf_prompt " --query="$fzf_query" | \
			     tr '\n' ' ' | \
			     sed 's/[ \t]$//')
	    ;;

    esac

    ## selection to buffer
    [[ -n "$fzf_output" ]] && \
    	CUTBUFFER="$fzf_output" && zle vi-replace-selection
    [[ -z "$fzf_output" ]] && \
    	CUTBUFFER="$fzf_query" && zle vi-put-before

    ## replace selection
    zle put-replace-selection

    unset CUTBUFFER
}
#! /usr/bin/env sh

# --------------------------------------------------------------------
# insert-item-inline.sh


function insert-item-inline ()
{
    # fzf search and select files and directories

    unset srch_env_prmt_arr
    unset srch_env_dir_arr
    unset srch_env_naa
    unset fzf_output
    unset fd_path
    unset fzf_prompt

    ## dir names and their fzf_prompts
    declare -A srch_env_prmt_arr
    srch_env_prmt_arr[CWD]='C'
    srch_env_prmt_arr[HOME]='H'
    srch_env_prmt_arr[ROOT]='R'

    ## dir names and their actual dirs
    declare -A srch_env_dir_arr
    srch_env_dir_arr[CWD]=$PWD
    srch_env_dir_arr[HOME]=$HOME
    srch_env_dir_arr[ROOT]=$ROOT

    ## search and select item(s) in $PWD
    ## fzf_query
    ## select & kill word on cursor
    zle select-in-blank-word
    zle kill-region
    fzf_query="$CUTBUFFER"

    ## dirstack instead of fd_path (below)
    dirstack

    fd_options='--'
    fzf_prompt='S'

    ## offer directories in reach
    insert-item-fzf $dir_stack $fd_options $fzf_prompt $fzf_query

    unset dir_stack
    unset fzf_prompt

    if [[ -n $fzf_output ]]; then

    	zle reset-prompt
     	return 0

    elif [[ -z $fzf_output ]]; then

	## choose search environment
	fzf_prompt='SRCH_ENV'

	## add quit option
	srch_env_dir_arr[ZQXIT]='ZQXIT'

	## iterate over associated array (zsh) and get all keys
	for srch_env_dir in "${(@k)srch_env_dir_arr}"; do

	    ## make (non-acc) array
	    srch_env_naa+=($srch_env_dir)

	done

	## HOME always first
	## of srch_env_naa make first item HOME and
	## sort the rest of the items in the array
	tail_env_dirs=()
	## easier fzf select; need home almost always
	first_dir='HOME'

	## array (tail_env_dirs) without first_dir
	for dir in "${srch_env_naa[@]}"; do

	    if [[ "$dir" != "$first_dir" ]]; then

		tail_env_dirs+=("$dir")

	    fi

	done

	## sort tail_env_dirs array
	IFS=$'\n' tail_env_dirs_sort=($(sort <<< "${tail_env_dirs[@]}"))
	unset IFS

	srch_env_dirs=("$first_dir" "${tail_env_dirs_sort[@]}")

	## one item from srch_env_dirs becomes fd_path_sel
	## PWD, HOME, ROOT, ...
	fd_path_sel=$(printf '%s\n' "${srch_env_dirs[@]}" | fzf --prompt "$fzf_prompt ")

	if [[ -z $fd_path_sel || $fd_path_sel == 'ZQXIT' ]]; then

	    zle reset-prompt

	else

	    fd_path=${srch_env_dir_arr[$fd_path_sel]}
	    fd_options='--'
	    fzf_prompt=${srch_env_prmt_arr[$fd_path_sel]}
	    #fzf_query=$fd_path/

     	    insert-item-fzf $fd_path $fd_options $fzf_prompt $fzf_query

	    zle reset-prompt
	    return 0

	fi

    fi
}

zle -N insert-item-inline
#! /usr/bin/env sh

# --------------------------------------------------------------------
# keys.sh


# fix the workings of important keys

## get terminal escape sequence (SIGTERM) string via `cat` and
## pressing the targeted key there

### -M selects keymap
## backspace key in vicmd
bindkey -M vicmd '^?' backward-delete-char
## delete key in vicmd
bindkey -M vicmd '^[[3~' delete-char
## delete key in viins
bindkey -M viins '^[[3~' delete-char

## select viins keymap and bind it to main
bindkey -v

## add backspace (key sequence '^?') to main keymap
bindkey -v '^?' backward-delete-char

## inline history search
## NOTICE works also from vicmd with j and k (recommended)
### up arrow
autoload -U up-line-or-beginning-search
zle -N up-line-or-beginning-search
bindkey '^[[A' up-line-or-beginning-search
### down arrow
autoload -U down-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey '^[[B' down-line-or-beginning-search

## fOrm-feed (default C-l)
bindkey '^o' clear-screen               ## C-o


# for info on zsh keybindings:
# showkey --scancodes
# bindkey -l (zsh keymaps)
# bindkey -M <keymap>

# zsh -f /usr/share/zsh/functions/Misc/zkbd
# find keycode in zsh terminal with cat
# bindkey  now to clipboard             ## C-`

# spawn terminal into cwd
## M-S-Return
## --> see sway config


bindkey '^@' insert-date-time           ## C-2
bindkey '^E' insert-epoch               ## C-e
bindkey '^A' git-add-commit             ## C-a
bindkey '^h' cd-nav-dirs                ## C-h
bindkey '^j' cd-child                   ## C-j
bindkey '^k' cd-up                      ## C-k
bindkey '^l' cd-yazi                    ## C-l
bindkey '^y' abs-rel-path-tgl           ## C-y
bindkey '^f' insert-item-inline         ## C-f
bindkey '^Z' foreground                 ## C-z


bindkey -M vicmd 's' toggle-sudo        ## [vicmd] s
bindkey -M vicmd 'q' toggle-sh-x        ## [vicmd] q

: '
# additional notes on keybindings (oxo spicules)
bindkey -M vicmd 'cc'  ## change current line (clear > viins)
bindkey escape sequence: C-v $key (C-v ESC -> ^[)
# '
#! /usr/bin/env sh

# --------------------------------------------------------------------
# modules.sh


# load zsh modules

## datetime provides among other $EPOCHREALTIME
zmodload zsh/datetime
#! /usr/bin/env sh

# --------------------------------------------------------------------
# precmd.sh


function precmd ()
{
    ## precmd runs before each prompt
    ## and thus runs after each command execution

    exit_code=$?

    ## WARNING exit_code must be obtained at the start of the precmd
    ## otherwise there is probably interference with the commands
    ## from within precmd itself

    # get t1 for $time_exec (ns)
    t1_exec_ns=$(date +'%s%N')

    # get execution time (ms)
    ## prevent errors if empty t0_exec_ns (i.e. zsh (re)start)
    [[ -n $t0_exec_ns ]] && \
	time_exec_ms=$( echo "scale=0; ( $t1_exec_ns - $t0_exec_ns ) / 1000000 " | bc -l )

    ## time_exec prettyfied
    t_ex_pretty=$(printf '%s' "$time_exec_ms")
    t_ex_len=${#time_exec_ms}
    t_ex_ms=${time_exec_ms: -3}

    if [[ $t_ex_len -gt 3 ]]; then

	t_ex_secs=${time_exec_ms%???}

    else

	t_ex_secs=''

    fi

    ## prompt path color
    if [[ -w $PWD ]]; then

	### normal state (user write permissions)
	### [zsh: 13 Prompt Expansion](https://zsh.sourceforge.io/Doc/Release/Prompt-Expansion.html)
	### single quotes; wait with expansion until print
	local precmd_left='%F{blue}%B%~%f%b $(git-branch "%s") $(git-dirty "%s")'

    else

	### no write permission directory color (amber #ffbf00)
	### single quotes; wait with expansion until print
	local precmd_left='%F{#000000}%K{#ffbf00}%B %~ %b%k%f $(git-branch "%s") $(git-dirty "%s")'

    fi

    ### right side
    if 	[[ -n $t0_exec_ns ]]; then

	# histcounter prettyfied by offset
	hc=$(( HISTCMD - 1 + $hist_cmd_offset ))

	## set precmd_right based on exec_time and exit_code
	if [[ $exit_code -eq 0 ]]; then

	    if [[ -n $t_ex_secs ]]; then

		## we have an exec time > 1000 ms
		### single quotes; wait with expansion until print
		local precmd_right='$t_ex_secs%F{#696969}$t_ex_ms%f $hc %D{%H%M%S}'

	    else

		## we have an exec time < 1000 ms
		### single quotes; wait with expansion until print
		local precmd_right='%F{#696969}$t_ex_ms%f $hc %D{%H%M%S}'

	    fi

	else

	    ## exit code
	    if [[ -n $t_ex_secs ]]; then

		## we have a exec time > 1000 ms
		### single quotes; wait with expansion until print
		local precmd_right='$t_ex_secs%F{#696969}$t_ex_ms%f %F{#ff6c60}$hc%f %D{%H%M%S}'

	    else

		## we have an exec time < 1000 ms
		### single quotes; wait with expansion until print
		local precmd_right='%F{#696969}$t_ex_ms %F{#ff6c60}$hc%f %D{%H%M%S}'

	    fi

	fi

    else

	# no starttime detected
	# when starting zsh or enter an empty line
	### single quotes; wait with expansion until print
	local precmd_right='* %D{%H%M%S}'

    fi

    ## https://developerfacts.com/answer/2267155-what-does-sstringkf1bbkf-mean
    ## position, alignment and optional correction parameters
    local l_precmd_r=${#${(S%%)precmd_right//(\%([KF1]|)\{*\}|\%[Bbkf])}}  ## errors with other excl_pttrn
    #local l_precmd_r=$(strlen $precmd_right)

    local l_precmd_corr=0

    local l_precmd_pad=$(( COLUMNS - l_precmd_r - l_precmd_corr ))

    ## print
    ## double quotes; expansion occurs here

    print -Pr "${(l:$l_precmd_pad:)}$precmd_right"
    print -Pr "$precmd_left"

    unset t0_exec_ns
    ## for rps1
    export t1_exec_ns
}
#! /usr/bin/env sh

# --------------------------------------------------------------------
# preexec.sh


function preexec ()
{
    ## runs before each command execution
    ## execution start time right side aligned (> 154550)

    # get t0 for $time_exec (ns)
    # not equal to (pretty) start_time!!
    t0_exec_ns=$(date +'%s%N')
    ### %1d at least one 0 in t0_epoch
    t0_epoch=$(printf "%1d\n" ${t0_exec_ns: 0 : -9})

    start_time_hms=$(date -d @$t0_epoch +'%H%M%S')
    start_time=$(printf '> %s' "$start_time_hms")

    local len_right_wo_corr=$(strlen "$start_time")
    local corr=1
    #local len_right=$(( $len_right_wo_corr ))
    local len_right=$(( $len_right_wo_corr + $corr ))
    local right_start=$(( $COLUMNS - $len_right ))

    local len_cmd=$(strlen "$@")
    local len_prompt=$(strlen "$PS1")
    local len_left=$(( $len_cmd + $len_prompt ))

    pre_exec_right="\e[${right_start}C ${start_time}"

    ## if end of $PROMPT lays left of first column of $pre_exec_right
    if [ $len_left -lt $right_start ]; then

	## then we have enough columns and we shift one line up
        echo -e "\e[1A${pre_exec_right}\e[0m"

    else

        # no upshift to prevent left prompt overwriting
	echo -e "${pre_exec_right}"

    fi
}
#! /usr/bin/env sh

# --------------------------------------------------------------------
# ps1.sh


# prompt

## prompt is PS1 (left side) and RPS1 (right side)
## see: note zsh oxo_prompt for explanation of all the prompt items
setopt PROMPT_SUBST

## left side prompt (PS1)
## defaults to only '%' (lights out phylosophy)

## ternary expressions %(expr.true.false)
## for exit code (?) and background jobs (j)
## [zsh: 13 Prompt Expansion](https://zsh.sourceforge.io/Doc/Release/Prompt-Expansion.html#Conditional-Substrings-in-Prompts)
[[ $(host) != "$HOSTNAME" ]] && \
    PS1="%(?..%F{#ff6c60}%?%f)%(1j.%F{#4aa5fd}%K{#333333}%B%j%b%k%f.)%F{#000000}%K{#cccccc}%n@%m%k%f%(!.%F{#ffbf00}%B#%b%f.%%) " || \
    PS1="%(?..%F{#ff6c60}%?%f)%(1j.%F{#4aa5fd}%K{#333333}%B%j%b%k%f.)%(!.%F{#ffffff}%B#%b%f.%%) "
#! /usr/bin/env sh

# --------------------------------------------------------------------
# ps4.sh


# debug prompt (PS4)

## set in zshenv
#! /usr/bin/env sh

# --------------------------------------------------------------------
# rps1.sh


strlen_sh="$XDG_CONFIG_HOME/zsh/function/strlen.sh"


## right side prompt (RPS1)
## shows running time without breaking menus (like fzf or zsh completion)

## no indentation for RPS1
ZLE_RPROMPT_INDENT=0


function calc-epoch ()
{
    epoch=$(date +'%s')
    ep_l=$(printf "$epoch" | cut -c 1-4)
    ep_r=$(printf "$epoch" | cut -c 5-)
}


## define what to display in RPS1
function calc-rps1 ()
{
    #TODO below TM_OUT threshold RPS1 shows irrelavant data
    calc-epoch
    source $strlen_sh

    ## weekday, daynum, epoch and time
    #weekday=$(date +'%u')
    #day_num=$(date +'%d')
    #rp='$weekday $day_num%F{#696969}$ep_l $ep_r%f %D{%H%M%S}'

    ## only time
    #rp='%D{%H%M%S}'

    ## elapsed time and current time
    elapsed_time_conversion
    rp="$et"' %D{%H%M%S}'

    ## length exit code in PS1
    if [[ "$exit_code" -gt '0' ]]; then

	l_exit=$(printf "$exit_code" | wc -c)

    else

	l_exit='0'

    fi

    ## length jobnumber in PS1 (1-9=1, 10-99=2, ...)
    l_jobs=$(jobs | wc -l)

    ## length PS1
    l_ps1=$(strlen $PS1)

    ## length rp
    l_rp=${#${(S%%)rp//(\%([KF1]|)\{*\}|\%[Bbkf])}}  ## errors with other excl_pttrn
    #l_rp=$(strlen $rp)

    ## correction factor
    #TODO DEV why and why 1?
    l_corr=1

    ## define RPS1 space padding
    ## so that RPS1 hides when start typing
    rp_padding=$(( COLUMNS - l_exit - l_jobs - l_ps1 - l_rp - l_corr ))

    ## set right prompt
    ## prints daynum epoch and time right side aligned
    RPS1="${(l:$rp_padding:)}$rp"

    ## control visability of RPS1
    [[ $RPS1_VIS != 'on' ]] && RPS1=''
}


elapsed_time_conversion ()
{
    ## timestamp
    ### t1_exec_ns exported from precmd
    ts=$(head -c 10 <<< "$t1_exec_ns")
    ## current time
    ct=$(date '+%s')
    ## elapsed time
    et=$(( ct - ts ))

    ## below threshold et is printed as elapsed time in seconds
    ## above threshold et is printed in '[d] hms' format
    ## dhms_th treshold in seconds
    dhms_th=600

    ## define dhms (with single digits for if statements)
    d="$(( et/60/60/24 ))"
    h="$(( et/60/60%24 ))"
    m="$(( et/60%60 ))"
    s="$(( et%60 ))"

    if [[ "$et" -gt "$dhms_th" ]]; then
	## less than one day passed
	## less than one hour passed
	## more than ten minutes passed

	## hms prettified with leading zeros
	h=$(printf '%02d' "$h")
	m=$(printf '%02d' "$m")
	s=$(printf '%02d' "$s")
	et="$h$m$s"

    elif [[ "$d" -gt 0 ]]; then
	## more than one day passed

	## hms prettified with leading zeros
	h=$(printf '%02d' "$h")
	m=$(printf '%02d' "$m")
	s=$(printf '%02d' "$s")
	et="$d $h$m$s"

    fi
}


function rp-redisplay ()
{
    ## updates RPS1 via TRAPALRM every TMOUT seconds
    ## disable from cli with: export RP_REDISPLAY='off'

    ## control auto redisplay of $RPS1
    [[ -z $RPS1_TRAP || $RPS1_TRAP == 'off' ]] && return

    fzf_active_tpgid=''
    curr_term_ppid=''
    fzf_active_ppid=''
    fzf_active_curr_term=''

    ## fzf active somewhere
    ## this gets all tpgid('s) of processes with fzf active
    fzf_active_tpgid=$(ps -C fzf -o tpgid=)
    #fzf_asw=$(ps -C fzf -o tpgid=)

    if [[ -n "$fzf_active_tpgid" ]]; then

	return
	### prevent interference with fzf in currently active terminal
	#curr_term_ppid=$(swaymsg -t get_tree | jq '.. | select(.type?) | select(.focused==true) | .pid')

	#IFS=$'\n'
	#for tpgid in $fzf_active_tpgid; do

	#    ## get ppid of current tpgid
	#    fzf_active_ppid=$(ps -g $tpgid -o ppid --no-headers | sort | head -n -1)

	#    ## current active terminal ppid is the same
	#    fzf_active_curr_term=$(printf '%s\n' "$fzf_active_ppid" | grep "$curr_term_ppid")

	#    if [[ -n "$fzf_active_curr_term" ]]; then

	#	## don't refresh rps1
	#	return

	#    fi

	#done

    fi

    ## only when $RPS1 exists and nothing is typed in buffer
    if [[ -z "$BUFFER" ]]; then

	   calc-rps1

	   ## prevent error on initial activation
	   ## when zle is not yet active
	   zle && { zle reset-prompt; zle -R }
	   #zle reset-prompt

    fi
}


function TRAPALRM ()
{
    rp-redisplay
}


## right side prompt (RPS1)
## TMOUT triggers the TRAPALRM
## RPS1 refresh rate (seconds)
TMOUT=3

## RPS1 initial activation
rp-redisplay
#! /usr/bin/env sh

# --------------------------------------------------------------------
# shell-params.sh


# shell parameters
autoload -U colors; colors
setopt auto_pushd


zle -N zle-line-init
zle -N zle-keymap-select
zle -N zle-line-finish
#! /usr/bin/env sh

# --------------------------------------------------------------------
# strlen.sh


function strlen ()
{
    # calculate string length
    ## called by preexec
    ## original
    arg=$1
    #local excl_pttrn='%([KF1]|)([BSUbfksu]|([FB]|){*})' ## errors
    #local excl_pttrn='%([BSUbfksu]|([FK]|){*})'
    local excl_pttrn='%([KF1]|)({*\}|[Bbkf])}'
    #local excl_pattrn='%([BSUbfksu]|([FB]|){*})'
    ## ~excl_pttrn ensures that excl_pttrn,
    ##  is treated as a pattern rather than as a plain string
    ## ${(S%%)arg//$~excl_pttrn/} matches ${arg//pattern/repl}
    ## S makes matching non-greedy shortest possible match
    ## repl is empty, basically removing the shorteest possible match
    local length=${#${(S%%)arg//$~excl_pttrn/}}
    echo $length
}


function xstrlen ()
{
    ## alternative strlen fuction
    ## https://github.com/romkatv/powerlevel10k/blob/master/internal/p10k.zsh
    : '
This function, strlen, calculates the length of a given string in bash.
It uses a loop to double the size of a variable y, until it is larger
than the length of the string.
Then it repeatedly halves y and checks if the substring of the
input string from 0 to y is equal to y.
If it is, it sets x to y and repeats the process until
it finds the length of the string.

    # '
    # calculate $1 string length
    ## alternative

    ## initialize variables
    ## y is the length of $1
    local -i x y=${#1} m

    if (( y )); then

	# loop until y is larger than the length of the string
	## the condition is checking if the first argument passed
	## to the command is less than or equal to 1, and if it is not, the loop will exit
	while (( ${${(%):-$1%$y(l.1.0)}[-1]} )); do

            # double the size of y
	    x=y
	    (( y *= 2 ))

	done

        # binary search to find the length of the string
	while (( y > x + 1 )); do

	    ## calculate the midpoint of the range x to y
	    (( m = x + (y - x) / 2 ))
	    ## check if the length of the string is equal to the
	    ## midpoint m. If it is, then the length of the string is m
	    (( ${${(%):-$1%$m(l.x.y)}[-1]} = m ))

	done

    fi

    echo $x
}
#! /usr/bin/env sh

# --------------------------------------------------------------------
# toggle-sh-x.sh


function toggle-sh-x ()
{
    [[ -z $BUFFER ]] && zle up-history

    if [[ $BUFFER == sh\ -x\ * ]]; then

	## replace sh -x with sh
	BUFFER="${BUFFER/sh -x /sh }"
	# remove sh -x
	#BUFFER="${BUFFER#sh -x }"

    elif [[ $BUFFER == sh\ * ]]; then

	## add -x to sh
	BUFFER="${BUFFER/sh /sh -x }"

    else

	## add sh -x
	BUFFER="sh -x $BUFFER"

    fi

    zle -R $BUFFER  ## refresh
}

zle -N toggle-sh-x
#! /usr/bin/env sh

# --------------------------------------------------------------------
# toggle-sudo.sh


function toggle-sudo ()
{
    [[ -z $BUFFER ]] && zle up-history

    if [[ $BUFFER == sudo\ * ]]; then

	## already sudo; remove sudo
	BUFFER="${BUFFER#sudo }"

    else

	## add sudo
	BUFFER="sudo $BUFFER"

    fi

    ## refresh
    zle -R $BUFFER
}

zle -N toggle-sudo
#! /usr/bin/env sh

# --------------------------------------------------------------------
# zz-catalog.sh


zsh_config_dir="$XDG_CONFIG_HOME/zsh"
zsh_catalog="$XDG_DATA_HOME/c/git/note/catalog/source/zsh"

# create source file for oxo note catalog
cat $zsh_config_dir/.zshrc > "$zsh_catalog"
cat $zsh_config_dir/function/*.sh >> "$zsh_catalog"
