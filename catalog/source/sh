#! /usr/bin/env sh  ## shebang (crunchbang) interpreter directive; search $PATH for sh
~+  ## alias $PWD
~-  ## alias $OLDPWD
: '\nmulti\nline\ncode\nblock\n# '  ## switchable multiline codeblock (prepend with #) / comment
< $file  ## less $file (via READNULLCMD)
< ${$(get-newest-file $XDG_LOGS_HOME/upgrader/$HOST/package_lists/)%?}Q  ## make last character of newest file a Q and print that file (latest upgrade)
apropos . | fzf | awk '{print $1}' | xargs -r man  ## fzf search apropos and open manpage (man -k)
echo hello 1> $file  ## stdout redirect to $file
echo hello 2>> $file   ## stderr redirect append to $file
echo hello > /dev/null 2>&1  ## stdout redirect devnull; stderr append to stdout; silent execution
echo hello &> /dev/null  ## stdout redirect devnull; stderr append to stdout; silent execution (shorthand notation)
echo hello 2>&1 | tee -a $logfile  ## stderr append to stdout; append both to $logfile
echo hello &| tee -a $logfile  ## stderr append to stdout; append both to $logfile (shorthand notation)
alacritty msg config font.size=18  ## current alacritty instance font size 18 (for screencasting)
amixer info  ## info about alsamixer device
amixer scontrols  ## list of alsamixer controls
amixer set Capture toggle  ## alsamixer toggle mic
amixer set Capture volume 0 nocap  ## alsamixer mute mic
amixer set Internal Mic Capture volume 0 nocap  ## alsamixer mute mic
amixer set Capture toggle && amixer get Capture | grep '\[off\]' && notify-send "MIC switched OFF" || notify-send "MIC switched ON"  ## mute mic with visual status update
amixer set Master playback volume 30 unmute  ## alsamixer unmute playback volume 30
apropos keyword  ## search man page names and descriptions
arecord --vumeter stereo audio.wav  ## record wave audio
ascii=$(for (( i=32; i<127; i++ )) do; printf "\\$(printf %03o "$i")"; done)  ## 95 printable ascii characters (0x20-0x7e 0d32-0d126)
number=$(printf '%s' "$ASCII" | cut --characters 17-26)  ## 10 number characters from $ASCII
upper=$(printf '%s' "$ASCII" | cut --characters 34-59)  ## 26 uppercase letter characters from $ASCII
lower=$(printf '%s' "$ASCII" | cut --characters 66-91)  ## 26 lowercase letter characters from $ASCII
alnum=$(printf '%s' "$ASCII" | cut --characters 1-16,27-33,60-65,92-95 --complement)  ## 62 alphanumeric characters from $ASCII
alnum=$(printf '%s' "$ASCII" | grep --only-matching  . | sort | tr -d "\n" | cut --characters 1-33 --complement)  ## 62 alphanumeric characters from $ASCII
punct=$(printf '%s' "$ASCII" | cut --characters 1-16,27-33,60-65,92-95)  ## 33 punctuation characters from $ASCII
punct=$(printf '%s' "$ASCII" | grep --only-matching . | sort | tr -d "\n" | cut --characters 1-33)  ## 33 punctuation characters from $ASCII
bas64=$(printf '%s' "$ASCII" | cut --zero-terminated --characters 34-59,66-91,17-26; printf '+/\n')  ## 64 base64 characters from $ASCII
awk '!($1="")' $file  ## remove column 1
awk 'NF{NF-=1};1'  ## remove last column
awk '{tmp = $1; $1 = $2; $2 = tmp; print;}'  ## swap columns 1 and 2
awk 'NR == 1; NR > 1 {print $0 | "sort -n"}'  ## sort stdin, omit first header line
awk 'NR==1{prev=$1;print $2} NR>1 && prev!=$1{prev=$1;print $2} END{if(NR>1)print $2}'  ## print col2 every time col1 value changes
awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }'  ## reverse lines (emulate tac)
awk '{for(i=1; i<=NF; i++) if($i=="version") print $(i), $(i+1)}' <<< $(echo 'a b c version 2 d e f')  ## extract string and following
basename $filepath  ## print filename without any leading directory components
echo ${filepath##*/}  ## emulate basename with parameter expansion
echo $filepath | sed 's#.*/##'  ## emulate basename using sed (remove all until last /)
bash -c 'echo $SRANDOM'  ## 32bit pseudo random number
bind '"\e[0n": "$string"'; printf '\e[5n'  ## inject $string to bash stdin
bindkey  ## zsh bound keys
blkid --match-tag UUID --output value /dev/sda1  ## /dev/sda1 uuid
bluetoothctl connect $(bluetoothctl devices | fzf | awk '{print $2}') && bluetoothctl info  ## bluetooth connect
bluetoothctl disconnect $(bluetoothctl devices | fzf | awk '{print $2}') && bluetoothctl info  ## bluetooth disconnect
bluetoothctl discoverable off	## bluetooth not broadcast radio device
bluetoothctl power off && sudo systemctl stop bluetooth.service && sudo rfkill block bluetooth  ## bluetooth radio off
sudo rfkill unblock bluetooth && sudo systemctl start bluetooth.service && bluetoothctl power on && bluetoothctl discoverable off  ## bluetooth radio on
brightnessctl set 50%  ## set brightness to 50% of the maximum
cal -m -w -3 $(date -I)  ## calendar weeknumbers, last, current and next month, week start on mondays
cal -m -w -y $(date +%Y)  ## calendar current year
cal -m -w 12 2022  ## calendar for december 2022
cat $HOME/c/keys/wl/ap.wifi | grep '#psk' | awk -F "\"" '{print $2}' | qrencode -t utf8  ## wifi accesspoint password qr
cat $HOME/a/data/emoji/emoji-test.txt | sed 's/^.*#//' | sed --regexp-extended 's/E[0-9]+.[0-9]//' | sed 's/^[ \t]*//' | sed '/^[[:alnum:]]/d' | sed '/^\s*$/d' | fzf | awk '{print $1}' | wl-copy -n  ## emoji & symbols to clipboard
cat -n $file  ## line number cat
cat -vE $file  ## prevent cat shell injection
cat 0< $file >1 /dev/stdout  ## rudimentary form of: cat $file
cat <(ls)  ## process substitution reading from list <() (?without subshell?); same as ls | cat  (piping ?with subshell?) #DEV
cat $split_file1 $split_file2  ## join split files
echo hello > >(sha512sum > file_with_hello_sha512.hash)  ## process substitution (instead of filename) writing to list >()
< /etc/group  ## list all user groups
cd $(fd --type d --hidden . $HOME | fzf --preview="tree -L 1 {}" --bind="space:toggle-preview" --preview-window=:hidden)  ## fzf cd from $HOME, spacebar for info box
cd ${PWD/share\/b/share\/c}  ## from backup to current tree
cd /usr/lib/modules/$(uname -r)  ## active os kernel modules
cd /var/lib/pacman/local  ## pacman install directory
cd $XDG_CONFIG_HOME/shln; sh chln; cd .; cd -  ## change symlinks to current $USER for $PATH
chattr -R +i $directory  ## add 'i' attribute: files in $directory cannot be modified
chmod --reference=ref_file target  ## make target file mode bits same as ref_file
chown -R $USER:$GROUP $target  ## recursive set target ownership to current user & group
chown :group file  ## set group ownership
chown user: file  ## set user ownership
clear  ## shift current line to top of screen
cmp $lf $rf  ## byte compare files, boolean output
command $command  ## run native $command, no alias or function, \command
command -v $command  ## check if $command exists
cp -prv --attributes-only  ## copy no content, but only mode, ownership and timestamps, verbose
cp -pv  ## copy and preserve mode, ownership and timestamps, verbose
cryptsetup --cipher=aes-xts-plain64 -hash=sha512 --key-size=512 --offset=0 --verify-passphrase open --type=plain /dev/sdX lvm
cryptsetup --cipher=aes-xts-plain64 -hash=sha512 --key-size=512 --offset=0 key-file=/dev/sdZ open --type=plain /dev/sdX lvm
cryptsetup --cipher=serpent-xts-plain -hash=sha512 --key-size=512 --iter-time=4096 --use-random --verify-passphrase luksFormat /dev/sdX
cryptsetup luksAddKey --key-slot 7 $vault  ## add luks key to slot 7 of $vault
cryptsetup luksRemoveKey $vault  ## remove luks key from $vault slot 7
cryptsetup luksDump $vault  ## dump $vault header information
cryptsetup luksChangeKey $vault  ## change a key for $vault
cryptsetup luksUUID $luks_container | wl-copy -o -n  ## get $luks_container id
cryptsetup open /dev/sdX cryptlvm  ## open /dev/sdX to cryptlvm
cryptsetup open /dev/sdX cryptroot --debug  ## which keyslot is used for passphrase
curl $(wl-paste) | zathura -  ## stream a copied (qb ;y) pdf url
curl -4 https://ident.me  ## external ip address
curl -O https://mirror.i3d.net/pub/archlinux/iso/2018.04.01/archlinux-2018.04.01-x86_64.iso | sudo dd of=/dev/sdX  ## download arch linux iso and write to device
curl -O https://file.location -C - -o file.location.txt_part  ## start or resume downloading file.location to file.location.txt_part
curl -O $(wl-paste) -C -  ## start or resume downloading copied location
curl -s 'https://archlinux.org/mirrorlist/?protocol=https&use_mirror_status=on' | sed -e 's/^#Server/Server/' -e '/^#/d'  ## arch linux active https server mirrorlist
cut -d , -f 5 --complement file.csv  ## remove column 5 from file.csv
date && sudo hwclock --show --verbose  ## read hardware clock time and its drift
date +'%s'  ## current linux epoch (oxo now)
ts=$EPOCHREALTIME; printf '%X.%x\n' ${ts%%.*} ${ts#*.}  ## current linux epoch hex (requires zmodload zsh/datetime)
ts=$(date +'%s.%N'); printf '%X%x\n' ${ts%%.*} ${ts#*.} | cut -c -16 | sed 's/.\{4\}/& /g'  ## epochrealtime (10^-8) hex prettified
date '+%-:::z %Z'  ## current time zone numeric and name/abbreviation
date -d 'June 28 03:14' +'%s'  ## convert specific date (tau day at pi time) to linux epoch
date -d "$(date -u)" +'%Y-%m-%dT%H:%M:%S%:z'  ## convert current zulu time to ISO8601
date -d '@1234567890' +'%Y%m%dT%H%M%S%z_%Z_%V_%s'  ## convert specific linux epoch to oxo extensive time format
date -d "$(wl-paste)" +'%Y%m%dT%H%M%S%z_%Z_%V_%s'  ## convert copied specific linux epoch to oxo extensive time format
date $DTE  ## date with zshenv strftime format preset
printf '%s_%X\n' "$(date $DT)" "$(date +'%s')"  ## dtx i.e.: 20250126_081507_6795E0FB
dd if=$src of=$dst bs=256k iflag=fullblock oflag=sync,noerror,notrunc status=progress  ## physical copy $src to $dst
dd if=/dev/zero of=$dst bs=256k count=1 iflag=fullblock oflag=sync,noerror,notrunc status=progress  ## write 1 * 256*2^10 zero bytes to $dst
dd if=/dev/urandom of=$dst bs=256k count=1 iflag=fullblock oflag=sync,noerror,notrunc status=progress  ## write 1 * 256*2^10 random bytes to $dst
echo '$idVendor:$idProduct:u' | sudo dd of=/sys/module/usb_storage/parameters/quirks  ## ignore uas, use usb-storage for storage device
df -h  ## human-readable file system space usage
df --si --exclude-type devtmpfs --exclude-type tmpfs --exclude-type efivarfs | awk 'NR == 1; NR > 1 {print $0 | "sort -n"}'  ## file system disk free space
df --portability $directory  ## get mountpoint (information) for given directory
dhcpcd -k $interface  ## dhcp remove interface ip
dhcpcd $interface  ## dhcp request for interface
diff --side-by-side --left-column $lf $rf  ## print $lf; $rf diffs in right column (-y --left-column)
diff --new-file --text --unified=3 --recursive $lf $rf > $patch_file  ## create recursive $patch-file unified with 3 lines of context from $lf to $rf (-Naur)
diff <(echo $(uname -r | grep --only-matching '[[:digit:]]' | tr -d '[:blank:]\t\r\n')) <(echo $(pacman -Q linux | grep --only-matching '[[:digit:]]' | tr -d '[:blank:]\t\r\n')) | tr -d '\n'; echo  ## kernel upgrade requires reboot ($? != 0)
dig -x 89.39.107.195  ## reverse lookup own public ip
dircolors --print-ls-colors  ## evaluate $LS_COLORS colors
dirname $filepath  ## print $filepath without last component
echo ${filepath%/*}  ## emulate dirname with parameter expansion (parent dir for $dirpath)
dotfbu restore $XDG_DATA_HOME/c/git/dotf $XDG_CONFIG_HOME  ## restore oxo system configuration
dotool --list-keys  ## list keys
dotool --list-x-keys  ## list x11 xkb keys
echo type hello | dotool  ## test dotool proper working
grep --invert-match '^#' "$BKMS" | fzf | awk -F '[()]' '{print $2}' | xargs echo type | dotool  ## insert bookmark url
du -sbh $directory  ## directory usage; total size of all content in directory
du --bytes --si --human-readable --separate-dirs --max-depth=0 $directory | awk '{print $1}'  ## directory usage; total si size of all files in current $directory
du --bytes --si --human-readable --separate-dirs --total $directory | tail --lines 1 | awk '{print $1}'  ## directory usage; total si size of all files and subdirectories
du --bytes --si --human-readable --separate-dirs $directory | sort -k 2  ## directory usage; list of all subdirectories with sizes (size sort -h -k 1)
du --bytes --si --human-readable --separate-dirs --total --all $directory | sort -k 2  ## directory usage; list of files and subdirectories with sizes (size sort -h -k 1)
e2label /dev/X  ## read device label
e2label /dev/X $label  ## write device label
echo "obase=02; ibase=16; $(echo $hex | tr a-z A-Z)" | bc  ## bc hexadecimal to binary conversion
echo "obase=10; ibase=16; $(echo $hex | tr a-z A-Z)" | bc  ## bc hexadecimal to decimal conversion
echo "obase=16; ibase=10; $dec" | bc  ## bc dec (10) to hex (16) conversion
echo "obase=02; ibase=10; $dec" | bc  ## bc dec (10) to bin (02) conversion
echo $(( 2#10 ))  ## decimal vailue of binary 10
echo $(( ~ 10 ))  ## bitwise NOT (all bits inverted)
echo $(( 10 & 2 ))  ## bitwise AND (output 1 if both input bits are 1 else 0)
echo $(( 10 | 2 ))  ## bitwise OR (output 1 if at least one of the input bits is 1 else 0)
echo $(( 10 ^ 2 ))  ## bitwise XOR (output 1 if only one of the input bits is 1 else 0)
echo $(( 10 << 2 ))  ## bitwise LEFT shift (adding zeros at least significant bitside; multiplication)
echo $(( 10 >> 2 ))  ## bitwise RIGHT shift (removing bits from least significant bitside; division)
echo -n $string | base64  ## base64 encoding
echo $?  ## print exit code of the last executed command
echo ${USER%??}$string  ## replace last two (%??) characters of $USER by $string
echo $RANDOM  ## pseudorandom integer (0-32767)
echo $(( RANDOM%95 + 32 ))  ## generate pseudorandom integer between 32 and 127 (included)
user='a'; admin='user'; echo ${!admin}  ## bash indirect parameter expansion (variable is not an array)
user='a'; admin='user'; echo ${(P)admin}  ## zsh indirect parameter expansion, with P flag
echo ${HOME#*/}  ## parameter expansion; remove */ short head; delete until first match (*/) from head (#); remove */ until first instance ('home/oxo')
echo ${HOME##*/}  ## parameter expansion; remove */ long head; delete until last match (*/) from head (##); remove */ until last instance ('oxo')
echo ${HOME%/*}  ## parameter expansion; remove /* short tail; delete from first match (/*) from tail (%); remove /* from last instance ('/home')
echo ${HOME%%/*}  ## parameter expansion; remove /* long tail; delete from last match (/*) from tail (%%); remove /* from first instance ('')
echo ${variable#pattern}  ##remove shortest match from start of variable
echo ${variable##pattern}  ##remove longest match from start of variable
echo ${variable%pattern}  ##remove shortest match from end of variable
echo ${variable%%pattern}  ##remove longest match from end of variable
echo ${a##* }  ## value when a='key value'
echo ${a% *}  ## key when a='key value'
echo ${a:-b}  ## parameter expansion; if [ -z $a ]; then return 'b'
echo ${a:=b}  ## parameter expansion; if [ -z $a ]; then assign 'b'
echo ${a/b/c}  ## in parameter a, replace first b (//b all) by c (a=abc echos acc)
var1=a; var2=b; var3=c; counter=2; naka="var$counter"; echo "${!naka}"  ## bash indirect referencing; treat a value (naka) as variable name
var1=a; var2=b; var3=c; counter=2; naka="var$counter"; echo "${(P)naka}"  ## zsh indirect referencing; treat a value (naka) as variable name
emacs --daemon  ## start emacs daemon
emacsclient --create-frame --alternate-editor="" $file &  ## client open $file in new gui window
emacsclient --tty $file &  ## client open $file in current terminal window
emacsclient -e '(kill-emacs)'  ## stop emacs daemon outside running instance
printenv  ## print values of environment variables
espeak -s 80 -p 70 -v mb-us1 'hello'  ## espeak hello speed 80% pitch 70% voice us1
eval $(ssh-agent) && ssh-add $XDG_DATA_HOME/c/keys/ssh/$ssh_key  ## concatenate arguments, add ssh_key
export $VAR  ## make local variable $VAR available as an environmental variable
faillock --user $USER --reset  ## remove sudo lockout for current user
fc -AI  ## append history to file; include internal (new) events only (update history file)
fc -RI  ## read history from file; include internal (new) events only (update shell/local/session history)
fc -e $editor  ## edit last command in $editor (fix command)
fc -l -n -1  ## last command entered
fc -l -d -t %Y%m%d_%H%M%S -D 1  ## list events from history list ($HISTFILE) with duration and timestamp from event 1 (interactive shell $- == *i*)
fc -l -d -t %Y%m%d_%H%M%S -D 1 | sort --reverse --numeric-sort --key 1 | sort --unique --key 4 | sort --numeric-sort --key 1 | fzf  ## fzf history search
fc -l -d -r -t %Y%m%d_%H%M%S -D 1 | sort --key 1n | sort --reverse --key 4 | uniq --count --skip-fields 3 | sort --key 1nr | nl --number-width 4 --number-separator ' '  ## unique command history list; line number, occurence frequnecy, latest history id, timestamp, execution time, command
fc-list  ## list available fonts (fontconfig)
fd $options $pattern $path  ## fd general synopsis, pattern default regex (--glob)
fd --format {/.} . $XDG_CONFIG_HOME/network/vpn/wg/proton/interface | fzf | xargs --no-run-if-empty -I {} wg-quick up {}  ## vpn wireguard proton interface up
fd --max-depth 1 --type symlink --hidden --exec bash -c '[[ ! -e {} ]] && echo "{}"' .  ## find broken symlinks, slower alternative using fd
fd --max-depth 1 --type file --hidden . .  ## list all files in current directory
fd --unrestricted . | fzf --query $(wl-paste) | wl-copy  ## fzf search clpb-string and copy (quick file search)
cat-audio() {ffmpeg -i "concat:${(j:|:)@[2,-1]}" -acodec copy $1}  ## concatenate mp3 audio files usage: cat-audio output.mp3 *.mp3
ffprobe -i $media_file -show_entries format=duration -v quiet -of csv="p=0" -sexagesimal  ## get $media_file duration (seconds or sexagesimal)
fg  ## recall last suspended command to foreground
fg %n  ## jobs item n to foreground
figlet -d $XDG_CONFIG_HOME/figlet  ## change default font directory
figlet -f 'mini' oxo  ## figchars
file $file  ## determine file type
find . -exec $command {} \;  ## find exec structure
find . -maxdepth 1 -name \*_ -type d -exec cp -r {} ~/test_/bu \;  ## find all dirs ending with _ and copy them (NOTICE: '\*_')
find . -maxdepth 1 -type d -exec du -sb {} \; | sort -g -k 1  ## directories sorted by size (bytes)
find . -maxdepth 1 -type f -name "* *" -exec sh -c 'mv "$0" "${0// /_}"' {} \;  ## replace filename spaces with underscores
find . -maxdepth 1 -type f -mtime $n  ## data modified less than (-n), more than (+n) or exactly n*24 hours (days) ago
find . -maxdepth 1 -type f -cmin $n  ## file status changed less than (-n), more than (+n) or exactly n minutes ago
find . -maxdepth 1 -type l -exec cp -d {} $HOME/.dot \;  ## find symlinks and copy without dereferencing (listing actual file where symlink points to)
find . -type f ! -newermt "2018-12-31" -delet3  ## find and delete all files older (not newer) than date
find . -type f -exec mv {} $dest \;  ## find all files and move them to $dest directory
find . -type l -exec sh -c "file -b {} | grep -q ^broken" \; -print  ## find broken symbolic links
find . -maxdepth 1 -xtype l -print  ## find broken symlinks in current directory (faster than fd alternative)
find . | sed -e 's;[^/]*/;|____;g;s;____|; |;g'  ## similar to: find . | tree
find . -iname $file  ## case_insensitive find
find $directory -name '$search_string' 2>/dev/null  ## find quiet
find $directory -type f -exec shred -v -z -n 3 -u {} \;  ## shred found files
find /var/cache/pacman/pkg -type f -name "*.gz" -o -name "*.xz" -o -name "*.zst" | sed 's#.*/##' | awk -F '-[0-9]+' '{print $1}' | sort | uniq  ## package names from package cache *.{gz,xz,zst} files (package.list)
setopt +o nomatch; printf '%s\n' /var/cache/pacman/pkg/*.{gz,xz,zst} | sed '/\*/d' | sed 's#.*/##' | awk -F '-[0-9]+' '{print $1}' | sort | uniq  ## package names from package cache *.{gz,xz,zst} files (package.list)
printf $string | fold -w 1  ## print each character of a string on a separate line (string to lines)
printf '%s' "$ASCII" | fold -w 1 | shuf | tr -d '\n'  ## randomize characters of the $ASCII string
for i in {1..95}; do; printf '%s' "$ASCII" | fold -w 1 | shuf | tr -d '\n'; echo; done; echo  ## otp random secret key from $ASCII
key=$ASCII; l=$(wc -c <<< "$key"); for (( r=0; r<$l-1; r++ )); do echo ${key:$r:$l}${key::$r}; done  ## otp conversion table from $ASCII
for file in *.html; do mv "$file" "${file%.html}.txt"; done  ## change file extension (*.html to *.txt)
for file in *; do cp -- "$file" "string_$file"; done  ## append string_ to each file in cwd
for i in {0..255}; do; printf "\x1b[38;5;${i}mcolor${i}\x1b[0m "; done; echo  ## print 256 colors
for i in {1..65535}; do (echo < /dev/tcp/127.0.0.1/$i) &>/dev/null && printf "\n[+] open port\n: \t%d\n" "$i" || printf "$i\r"; done  ## portscan
for i in {0..7}; do; printf "\033[0;3${i}mcolor$i\n"; done  ## print 8 colors
for i in ${list//,/ }; do; printf '%s\n' "$i"; done  ## loop through comma separated $list, transpose values to rows
free -m  ## free and used memory in system
sudo -k; free -h; echo; for i in {1..3}; do; sudo sysctl -w vm.drop_caches="$i"; sudo sync; echo "$i" | sudo tee /proc/sys/vm/drop_caches; done; free -h  ## free mwmory (pagecache, dentries and inodes)
fuser -vmM $file_system  ## display PIDs using file / file(system) (filesystem in mount)
fusermount -u $HOME/dock/mobile  ## umount simple-mtpfs mtp device
getent ahosts $url  ## get ip address from name service switch library database ahost
git -C $path $command  ## run $command as if git was started in $path
git -C $HOME/.config/hosts switch blocklist_on  ## activate network blocklist
git clone https://codeberg.org/oxo/hajime $XDG_DATA_HOME/c/git/code/hajime  ## git clone to specific directory
git config --show-scope --show-origin --list  ## origin and scope of git configuration
git diff -C $directory HEAD -- $file  ## changes in directory/file since last commit
git fetch $repo  ## download changes from remote repo without merging locally
git merge $repo/$branch  ## incorporate fetched changes into local branch
git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit  ## git hist
git log --oneline  ## list of commits
git log --patch  ## generate patch
git log -1  ## show commit log of last 1 commit (HEAD)
git pull $repo  ## fetching and merging remote repository
git push [-u] $repo $branch  ## -u sets the upstream tracking branch directly
git reset --hard 2db93df  ## back to a previous commit id
git rev-parse HEAD | cut --characters 1-10  ## HEAD commit id (online repo syntax)
gnutls-cli -d 1 grc.com -p 443  ## get certificate info
gpg --armor --export $kid > $kid.puk.gpg  ## export public key ascii armored id
gpg --detach-sign --local-user 0x12345678 $file  ## sign $file with specific secret key
gpg --edit-key $kid >  ## edit public key
gpg --export $kid > $kid.puk.gpg  ## export public key binary
gpg --export --export-options backup --output public_keys.gpg  ## step 1 backup gpg identity (public keys)
gpg --export-secret-keys --export-options backup --output private_keys.gpg  ## step 2 backup gpg identity (private keys)
gpg --export-ownertrust > trust_db.gpg  ## step 3 backup gpg identity (trust database)
gpg --import public_keys.gpg  ## step 1 restore gpg identity (public keys)
gpg --import private_keys.gpg  ## step 2 restore gpg identity (private keys)
gpg --import-ownertrust trust_db.gpg  ## step 3 restore gpg identity (trust database)
gpg --fingerprint | grep -i -B 1 $uid_email | head -n 1 | awk -F = '{print $2}' | sed ':a;N;$!ba;s/\n//g' | sed 's/ //g' | sed 's/\r$//g'  ## get gpg fingerprint w/o spaces from uid (email)
gpg --expert --full-generate-key  ## generate new keypair
gpg --import $kid  ## import public key by key id
gpg --list-keys | grep ^uid | sed s'/  //g' | fzf | awk '{print $NF}' | sed 's/<//' | sed 's/>//' | xargs -I {} sh -c "gpg --list-keys | grep -B 2 {}" | head -n 1 | awk -F = '{print $2}' | sed ':a;N;$!ba;s/\n//g' | sed 's/ //g' | sed 's/\r$//g'  ## get fingerprint from fzf uid list (grep -B 1 if keygrip is not shown)
gpg --output ID.puk.asc --armor --export ID >  ## export public key ascii armored
gpg --output file --decrypt file.gpg >  ## decrypt file.gpg asymmetric using private key
gpg --output file.gpg --encrypt --recipient ID file >  ## encrypt file asymmetric using public key ID
gpg --output file.gpg --symmetric file >  ## encrypt file symmetric
gpg -e -a -r $id file  ## encrypt file armored for recipient $id (like pass)
gpg --output revoke.asc --gen-revoke ID  ## generate revocation certificate
gpg --output $file.sig --sign $file  ## create a separate sig file
gpg --verify $file.sig [other_dir/$file]  ## verify a signature
gpg -vv $pub_key.asc  ## verbose info on $pub_key.asc
gpg-connect-agent reloadagent /bye  ## clear passphrases gpg cache
gpg-connect-agent 'keyinfo --list' /bye 2>/dev/null | awk 'BEGIN{CACHED=0} /^S/ {if($7==1){CACHED=1}} END{if($0!=""){print CACHED} else {print "0"}}'  ## gpg cache status (1=cached)
gpsbabel -i garmin_fit -f $in_fit -o gpx -F $out_gpx  ## fit2gpx conversion
printf $s2l | grep -o .  ## print each character of a string on a separate line (string to lines)
for i in $(seq 1 95 | grep -vFx 6); do echo "line $i"; done  ## loop through numbers 1 to 95, excluding 6 (exclude one line in loop)
grep "\sro[\s,]" /proc/mounts  ## show read only mountpoints
grep -riIl 'text' $directory  ## find files (no binary) containing text recursively in $directory
grep -riIn 'text' $directory  ## find files (no binary) containing text recursively in $directory with linenumbers
grep '^[[:blank:]]*[^[:blank:]#;]' $file  ## only lines not (2nd ^) starting (1st ^) with # or ; uncommented lines from file
grep '^[[:blank:]]*[^[:blank:]#;]' $XDG_CONFIG_HOME/alacritty/alacritty.yml | grep 'key:'  ## alacritty active (no outcommented) keybindings
grep bindsym $XDG_CONFIG_HOME/sway/config  ## sway keybinding related lines
grep bindkey $XDG_CONFIG_HOME/zsh/.zshrc  ## zsh keybinding related lines
grep --invert-match '^#' "$BKMS" | fzf | awk -F '[()]' '{print $2}' | wl-copy  ## copy bookmark url
grep '^c ' $XDG_CONFIG_HOME/.fpcl | sed 's/^c //' | xargs -I {} cp -r {} $dst/  ## #TODO not tested copy c marked directories in fpcl file to $dst
gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/default -dNOPAUSE -dQUIET -dBATCH -dDetectDuplicateImages -dCompressFonts=true -r150 -sOutputFile=out.pdf in1.pdf in2.pdf in3.pdf  ## concatenate pdf files
gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/default -dNOPAUSE -dQUIET -dBATCH -dDetectDuplicateImages -dCompressFonts=true -r150 -sOutputFile=out.pdf -dFirstPage=a -dLastPage=b $infile.pdf  ## extract pages a through b from $infile.pdf
head -n 2 $file  ## print $file first 2 lines
head -n -2 $file  ## print $file but last 2 lines (skip last 2 lines)
printf '☯' | hexdump  ## utf8 character encoding; NOTICE better use od or xxd
history  ## alias to fc -l
history -t %Y%m%d_%H%M%S -d -D $history_id  ## command history from $history_id (id time-start -elapsed cmd)
history -t %Y%m%d_%H%M%S -d -D -3  ## last 3 commands from history (id time-start -elapsed cmd)
history | tail -n 1 | tr -s ' ' | cut -d ' ' -f 3-  ## last command from history (removing history_id)
key=$(printf $input | openssl dgst -sha512 -hmac $input | sed 's/^.*= //')  ## zz2
host -t A $ip_addr_domain  ## dns lookup A record
host -v -t ANY $ip_addr_domain  ## dns lookup any type verbose output
hwclock --set --date='01/01/2010 00:00:00'; sudo hwclock --hctosys  ## set date and time
id -u $USER  ## show effective user id
id -g $USER  ## show effective group id
id -un $USER  ## show effective user name
id -gn $USER  ## show effective group name
id $USER  ## show both real and effective uid & gid
export IFS=', '  ## permanently assign comma and space as internal field separators (IFS as an environment variable)
IFS=$'\n'  ## newline as internal field separator
iftop -i $interface ## display bandwith usage of interface
info  ## advanced manual system primarily for gnu programs
insmod $file $args  ## insert module into kernel (if not in /usr/lib/modules/$(uname -r))
ip -c a  ## ip address; show network routing, devices, interfaces and tunnels in color
ip a | grep '^[0-9]' | awk -F ': ' '{print $2}'  ## network interface list
ip a add 192.168.1.200/255.255.255.0 dev $interface  ## assign ip address to interface
ip a add $ip_subnet_mask broadcast $broadcast_ip dev $interface  ## add interface
ip a del 192.168.1.200/24 dev $interface  ## remove ip address from interface
ip a flush $interface  ## remove all ip addresses from interface
ip link set $interface {down/up}  ## change interface state
ip link set dev $interface address $mac  ## assign $mac address to $interface
ip link set dev $interface down  ## disconnect from the network by disable $interface
ip neighbor show  ## show neighbor / arp cache
ip link show $enp | grep link | awk '{print $2}'  ## print $enp mac address
ip route add default via $default_gateway  ## add new $default_gateway
ip route flush dev $interface  ## flush routing tables for $interface
ip route show | grep default | awk '{print $5}'  ## currently active external facing network interface
ipset add blocklist $ipaddrs  ## add $ipaddrs to blocklist
ipset create blocklist hash:ip  ## create ip blocklist
iptables -A INPUT -s $ipaddr -j DROP  ## add ipaddr/ to chain INPUT and drop all traffic
iw dev $wl_interface scan | grep SSID | sort | uniq  ## received SSID list
jobs  ## list background processes (C-z initiates)
journalctl --disk-usage  ## show total size / disk space used
journalctl --flush --rotate  ## flush all journal data from /run to /var and request immediate rotation of the journal files
journalctl --vacuum-files=2  ## leave 2 journal files (--vacuum-size, --vacuum-time)
journalctl --list-boots  ##  ## list of boots with their numbers
journalctl --boot $id  ## messages from boot id (current -0, previous -1)
journalctl --pager-end  ## jump to eol on opening in pager tool
journalctl --follow  ## show most recent and print new
journalctl --dmesg  ## show only kernel messages
journalctl --dmesg --since '1 minute ago'  ## show kernel messages not oldeer than 1 minute
journalctl --output json-pretty  ## print json format (more options see man)
journalctl --output verbose  ## print all the fields
journalctl --priority 3 --catalog  ## emerg0, alert1, crit2, err3, warning4, notice5, info6, debug7
journalctl --unit $unit_pttrn  ## messages for unit [-pattern]
journalctl _<TAB>  ## search matches starting with '_'
jq '.data[0] | .ua' api.json  ## get ua in the first [0] data item of api.json
kill -l  ## list signal names (/usr/include/linux/signal.h) that can be send to jobs or processes
kill -STOP [$PID | %n]  ## suspend process [$PID or jobs item number n]
kill -CONT $PID  ## continue (resume) process [$PID or jobs item number n]
kill -TERM %n  ## terminate process [$PID or jobs item number n]
kill -KILL $(pidof $process_name)  ## forcefully terminate pid of process (can not be trapped or otherwise ignored)
let arg  ## evaluate arg as an arithmatic expression
limit  ## print all resource limits
ln $target $link_name  ## create hard link [with $link_name] to $target (target and link_name point to the same inode)
ln --symbolic $HOME/dock/vlt/pass $HOME/.password-store  ## pass vault symbolic link
ln --symbolic --force $target [$link_name]  ## create or replace symlink [with $link_name] to $target
cat $symlink  ## a symlink is a reference to a file; cat dereferences a symlink
losetup -l -a  ## list all loop devices
losetup -d $loop_dev  ## detach $loop_dev
ls $XDG_DATA_HOME/keys/wl | fzf | xargs -r cat | grep #psk | awk -F "\"" '{print $2}' | qrencode -t utf8  ## fzf select wifi key and show qr
lsblk -o name,fstype,uuid,path,size,fsuse%,fsused,label,mountpoint --ascii --tree  ## list block devices
lsblk -o name,fsuse%,fsused,size --sort fsuse% | grep '%' | tr -d '|-' | tr -d '\`' | column -t  ## block devices usage percentage
lscpu  ## display cpu architecture
lshw  ## list hardware configuration
lsmod  ## list modules currently added to kernel
lsof +f -- $path1 $path2  ## list open files in paths opened by processes
lsof -p $pid  ## list open files for $pid
lspci  ## list pci devices
lspci -k -d $vendor:$device:$class  ## show kernel drivers and modules (for vendor, device and/or classid)
lspci -k -s xx:xx.x $domain:$bus:$slot.$func  ## show kernel drivers and modules for domain
lspci -k -t -v  ## show kernal driver and module details in a tree
lspci -vv  ## list pci devices with more detail (useful to find kernel drivers)
lsusb  ## list information about usb devices
makepkg --syncdeps --install --rmdeps --clean  ## sync deps with pacman, pacman -U, remove build time deps and tempo build files
man ascii  ## 7-bit ascii tables
man zshall  ## view the system reference manual for all zsh
mkdir $HOME/dock/{1-4}  ## make multiple directories
tmp=$(mktemp); printf "$tmp\n"; head -c 1b </dev/urandom >"$tmp"  ## create a temporary file with 1b random data
nmcli connection add type ethernet con-name $conn_name ifname $if_name  ## nmcli add connection
nmcli connection modify $conn_name ipv4.addresses 192.168.0.39/24 ipv4.gateway 192.168.2.2 ipv4.dns 192.168.2.2 +ipv4.dns 9.9.9.9 connection.autoconnect no ipv4.method manual  ## nmcli modify connection
nmcli connection delete $conn_name  ## nmcli remove connection
nmcli device status | grep wireguard | awk '{print $NF}' | fzf --exit-0 | xargs --no-run-if-empty -I {} wg-quick down {}  ## vpn wireguard active interface down
nmcli device wifi hotspot con-name $conn_name ssid $conn_ssid band bg password $pwd  ## nmcli create hotspot
modprobe -r $driver  ## remove driver from kernel
modprobe $driver  ## add driver to kernel
mount -L $label $mountpoint  ## mount device with $label to $mountpoint
mount -o remount,rw /dev/sdY1 /boot  ## remount rw existing mountpoint
mount -o uid=$(id -u $USER),gid=$(id -g $USER) /dev/sdX dock/1  ## mount as current user
mount -t tmpfs tmpfs /mnt/ramdisk -o size=4096  ## create ramdisk
mount | grep ro,  ## find all ro mountpoints
mount | sort -k 1 | column -t  ## sort mount by device name
mount | sort -k 3 | column -t  ## sort mount by mountpoint
export PWGN_OFF=1; mountr  ## disable oxo pwgn; i.e. while executing mountr
mpv --start=+00:00 --ytdl-raw-options=format-sort=res:240 --profile=cache_xs --demuxer-cache-wait --msg-level=all=v --user-agent=$USER_AGENT $(wl-paste)  ## stream verbose with user-agent, best res under 480p and mpv.conf cache_xs profile
wl-paste | sed 's/youtube.com/yewtu.be/' | wl-copy  ## change to invidious url
mpv --audio-display=no $file.mp3  ## play mp3 without albumart
mpv /dev/video4  ## livestream local webcam
mv -t $target_dir $source_dirs  ## move source_dirs to target_dir
nerd-dictation begin --config $config_file --simulate-input-tool STDOUT --numbers-min-value 10 --numbers-as-digits --numbers-no-suffix --vosk-model-dir $model_dir  ## speech-to-text
neofetch --ascii_distro arch_small --gtk3 off --gtk2 off --colors 3 3 3 7 3 4 --separator '     \t'  ## neat system info
nl -w 3 -s ' '  ## add line numbers with number width 3 and separator string ' '
notmuch address '*'  ## all mail addresses
notmuch address --output=recipients --deduplicate=address date:year | fzf | wl-copy  ## last years recipients
notmuch address --deduplicate=address date:year | fzf | wl-copy  ## 1. last years email addresses
notmuch search $(wl-paste) date:year | fzf | awk '{print $1}' | wl-copy  ## 2. last years threads from recipient
notmuch show $(wl-paste)  ## 3. show specific thread content
notmuch address --output=count --deduplicate=address date:year '*' | sort --numeric-sort --reverse | fzf | wl-copy  ## last years email addresses, most to least active
nslookup server.com  ## get server ip address
echo -n '☯' | od --address-radix n --format x1 | sed 's/ /\\x/g'  ## 3 byte hex code from utf8 character
wl-paste | od --address-radix n --format x1 | sed 's/ /\\x/g'  ## 3 byte hex code from copied utf8 character
echo $'\xe2\x98\xaf'  ## utf8 character from 3 byte hex code
od --output-duplicates --address-radix=n --read-bytes 8 --format u4 < /dev/random  ## 8 random bytes interpret as (2) 4 byte decimal
od --output-duplicates --address-radix n --read-bytes 32 --format u < /dev/random | tr -d '[:blank:]\t\r\n'; echo  ## 32 random bytes interpret as unsigned decimal (x hex, d sign dec)
od --output-duplicates --address-radix n --read-bytes 32 --format a < /dev/random | tr -d '[:blank:]\t\r\n'; echo  ## 32 random bytes interprept as ascii
openssl enc -d -base64 -aes-256-gcm -pbkdf2 -salt -in crypt.aes -out plain.txt  ## decryption openssl base64 encoded aes 256 bits galois counter mode
openssl enc -e -base64 -aes-256-gcm -pbkdf2 -salt -in plain.txt -out crypt.aes  ## encryption openssl base64 encoded aes 256 bits galois counter mode
openssl s_client -connect grc.com:443 -showcerts < /dev/null | openssl x509 -outform pem > cert.pem  ## write x509 public key certificate from grc.com:443 as pem to file cert.pem
openssl s_client -connect $(wl-paste -n):443 -showcerts < /dev/null | openssl x509 -noout -text ## print x509 public key certificate as text to stdout
openssl s_client -connect $server_ip:443 -servername $server_name -showcerts  ## print x509 public key certificate from $(wl-paste -n):443 as text to stdout with server name indication (SNI) in the clienthello message (if a reverse proxy ip serves multiple webservers)
openssl x509 -in cert.pem -noout -text  ## print x509 public key certificate from file cert.pem as text to stdout
printf $text | openssl dgst -sha512 -hmac $key | sed 's/^.*= //'  ## sha512 hash of $text with hmac $key
openvpn --config openvpn/udp-ams1_udp.ovpn  ## open vpn with specific configuration
output=$(printf $input | openssl dgst -sha512 -hmac $key | sed 's/^.*= //')  ## zz3
pacman --root=/mnt --cachedir=/mnt/var/cache/pacman/pkg -Syu  ## upgrade (default) main system from alternate (i.e. archiso) boot
pacman -Q $(pactree --unique $package)  ## package version dependency list (-Qq without versions)
LC_ALL=C.UTF-8 pacman -Qi | awk '/^Name/{name=$3} /^Installed Size/{print $4$5, name}' | LC_ALL=C.UTF-8 sort -h  ## list installed packages; sort by human readable size
pacman-key --delete $pub_key  ## remove key from keyring
pacman-key --finger $pub_key  ## list fingerprint(s)
pacman-key --lsign-key $pub_key  ## locally sign key
pacman-key --verify $package.sig  ## manually verify package integrity
pactl list sinks | grep -A 1 Name  ## list of sink devices (audio output)
pactl list sources | grep -A 1 Name  ## list of source devices (audio input)
pactl set-source-port $device_name $port_name  ## set audio source (use tab to autocomplete)
pactl set-source-volume $device_name 100%  ## set audio source volume 100% (use tab to autocomplete)
pactl set-source-mute $device_name false  ## set audio source mute status false (use tab to autocomplete)
pactl list sources | grep -B 1 'Webcam C310 Mono' | head -n 1 | awk '{print $2}'  ## get audio source name from description (for wf-recorder --audio)
pactree -r $package  ## show $package dependant tree, reverse depedencies, packages that depend on $package
pactree $package  ## show $package dependency tree
sudo passwd -u $user  ## enable password for user
patch -p0 < $patch_file  ## apply $patch_file (see diff)
pim2fa=$(printf $output | openssl dgst -sha512 -hmac pim2fa | sed 's/^.*= //')  ## zz4
ping -D -i 1 -c 3 9.9.9.9  ## send icmp echo_request to quad9, print timestamp, interval 1s, 3 attempts
pkill wpa_supplicant && sudo dhcpcd -k wlp58s0 && sudo pkill dhcpcd && sudo ip a flush wlp58s0  ## end wireless network connection
pkill -SIGRTMIN+4 i3blocks  ## send signal=4 to i3blocks
print -z $string  ## inject $string to zsh stdin
printf "$tring" | awk '{print $1+0}'  ## awk retrieves the second field as a number (+0) from $tring, anything after the number will be ignored
printf "%03d%s" '2'  ## print leading zeros before a number (padding)
printf "%3d%s" '2'  ## print leading spaces before a number (padding)
printf "%x\n" \'A  ## ascii character (A) to hex value (41)
printf "%d\n" \'A  ## ascii character (A) to decimal value (65)
printf "\x$(printf %x 65)"  ## ascii hex value (65) to character (A)
printf "\x$(printf %d 41)"  ## ascii decimal value (65) to character (A)
printf "${fg_black}$(BGx aaaaaa)%s${st_def}\n" 'text_appearance'  ## printf 24 bit hex color code; NOTICE dependency: oxo source function text_appearance
printf "DEV$LINENO %s\n" "${v}"  ## debug variable value
printf "Mime-Version: 1.0; Content-Type: text/plain; charset=us-ascii; Content-Transfer-Encoding: 7bit; Subject: <subject>\n; <body>" | msmtp -v -C <msmtp_config> -a <profile_name> -- destination@mail.com  ## send email
printf "space_every_4th_char" | fold -w 4 | paste -sd ' ' -  ## space every 4th character (with fold)
printf "space_every_4th_char" | sed 's/.\{4\}/& /g'  ## space every 4th character (with sed)
printf $(( [#n] x ))  ## print base 10 value of x in base n, with 2<=n<=36
cat /proc/cmdline  ## view current kernel parameters
ps -ajf  ## print a process tree; all processes with tty, jobs format, full format
ps -eFly  ## list every process on the system
ps -eo %cpu,%mem,pid,pgid,user,state,start,args= --sort=-etimes  ## list processes custom AIX format descriptors, sort low to high elapsed time since process was started
ps -eo %cpu,%mem,pid,user,command= --sort=-%cpu  ## list processes custom AIX format descriptors, sort high to low cpu usage
ps -jxf | grep $(echo $$) | sort -n | head -n 1 | awk '{print $1}'  ## print currently active terminal ppid
ps -p $$ -o ppid=  ## print currently active terminal ppid
pstree -ptg  ## display a tree of processes, show PIDs, PGIDs and full names for threads
PS4=':${BASH_SOURCE[0]:-$0} $(printf %4d%s "${LINENO}") ${FUNCNAME[0]:+${FUNCNAME[0]}(): }' sh -xv script.sh  ## extra verbose debug output stream
pushd $directory  ## cd to $directory and add $directory to dirs stack[0]
qalc '-18.5458 to latitude'  ## convert decimal geographic position value to sexagesimal N/S notation
qalc '64.8587 to longitude'  ## convert decimal geographic position value to sexagesimal E/W notation
qalc '18°32′44.88″W to degrees'  ## convert sexagesimal value to decimal geographic position notation
qalc -s 'exp engineering' '1700000000'  ## convert value to engineering notation
qbns -s content.canvas_reading true -s content.webgl true -s colors.webpage.darkmode.enabled false $(wl-paste) &  ## qutebrowser new session open copied url unsafe
qrencode -t utf8  ## create qr from stdin
qutebrowser -s content.canvas_reading true  ## qb for windy
rankmirrors -n 10 /etc/pacman.d/mirrorlist | grep -w 'Server =' >> mirrorlist.ranked  ## update mirrorlist
read -r input  ## zz1; variable is assigned
read -er input  ## zz1; variable is not assigned
read -er input | tr -d '\n' | base64 | tr -d '\n' | wl-copy -n -o  ## input base64 translation without EOL
read -er input | base64 | wl-copy -n -o  ## input base64 translation
read -er input | tr -d '\n' | base64 | tr -d '\n' | openssl dgst -sha3-512 | sed 's/^.*= //'  ## secure sha3-512 hash from stdin (verify pwgn)
read -er input | base64 | wl-copy -n -o; dotfbu backup $XDG_CONFIG_HOME $XDG_DATA_HOME/c/git/dotf && gacp_all  ## backup oxo configuration & git add, commit and push to all remotes
IFS=', ' read -r -a array <<< "$string"  ## comma or space separated string to array
readlink $symlink  ## print resolved symbolic link (relative path)
readlink -f $symlink  ## print symbolic links' canonical (absolute path) file name
readlink -f $symlink | cut -d / -f 4- | awk -v home="$HOME/" '{print home $0}'  ## change canonical (absolute path) symbolic link to current users $HOME (NOTICE realpath is preferred)
realpath $file  ## return canonical file name (absolute path); $(dirname $file)/$(basename $file)
realpath $dir_in_home | sed "s#$HOME##"  ## remove "$HOME" from $dir_in_home
reflector --verbose --protocol https --country Iceland,Sweden,Germany,Denmark,Netherlands,United States --age 12 --latest 5 --sort rate --save /etc/pacman.d/mirrorlist  ## generate pacman mirrorlist
rename 'part' 'name' filepart  ## replace 'part' with 'name' in filepart (filepart -> filename)
rename --all ' ' _ *  ## replace all spaces in filenames with underscores
perl-rename 's|part|name|g' filepart  ## replace (s) all (g) 'part' with 'name' in filepart (filepart -> filename)
perl-rename 's/[^\w]+/_/g' *  ## replace (s) all (g) non- (^) alnum (\w) characters (+) in all (*) filenames with underscores
renice -19 $(pgrep $process_name)  ## give $process_name highest (-19) priority
reset && zsh  ## reinitialize terminal state and z-shel
return  ## return to the invoking script
rev $file  ## reverse line characters (for unknown field lengths)
rfkill list  ## check hard and soft block status wireless radios
rfkill [un]block bluetooth  ## soft [un]block bluetooth radio
rfkill [un]block all  ## soft [un]block all radios
rg --sort path --ignore-case --line-number pttrn .  ## ripgrep synopsis; $options $pattern $path
rm -rf -- '-r'  ## remove entire directory starting with a '-'
rmmod $module  ## remove $module from linux kernel
rsync --recursive $src $dst  ## create intervening directory $dst/$src; with all content of $src
rsync --recursive $src/ $dst  ## copy $src content 'flat' into $dst (like cp $src/.) NOTICE rsync trailing slash caveat
rsync -aAXv --delete --info=progress2,stats --progress --log-file $XDG_LOGS_HOME/rsync/$(date +'%Y%m%d_%H%M%S_%s') $source/ $destination  ## basic oxo rsync with logging
rsync -aAXv --delete --info=progress2,stats --progresss --log-file $XDG_LOGS_HOME/rsync/$(date +'%Y%m%d_%H%M%S_%s') --dry-run $XDG_DATA_HOME/c/ $XDG_DATA_HOME/b  ## dry run backup_c2b
rsync -aAXv --delete --info=progress2,stats --progress --log-file $XDG_LOGS_HOME/rsync/$(date +'%Y%m%d_%H%M%S_%s') --exclude-from=$exclude_patterns $source/ $destination  ## basic oxo rsync w exclude patterns
rsync -aAXv --delete --info=progress2,stats --progress --log-file $XDG_LOGS_HOME/rsync/$(date +'%Y%m%d_%H%M%S_%s') --files-from=$list_relative_to_source $source/ $destination  ## basic oxo rsync w files from patterns
rsync -aAXv --delete --info=progress2,stats --progress --log-file $XDG_LOGS_HOME/rsync/$(date +'%Y%m%d_%H%M%S_%s') --rsh=ssh $source $user@$host:/directory  ## basic oxo rsync w remote ssh shell
rsync -aAXv --hard-links --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/media/*","/var/lib/dhcpcd/*","/lost+found","$dst/*"} / $dst  ## full system backup
script; $command; exit  ## $command execution typescript user log
script; sh -x $command; exit  ## $sommand execution typescript developer debug log
script --command 'sh -x $command' --log-io "$(now).log" --log-timing "$(now).log"  ## $sommand execution typescript developer debug log_2
sed ':a;N;$!ba;s/\n//g' | sed 's/ //g' | sed 's/\r$//g'  ## remove all spaces from string
sed '/^\s*$/d'  ## delete empty lines
sed "${line_num}q;d" $file  ## print only line "$line_num" from $file
sed '/.*string.*/a inserted_line_after' $file  ## insert line after line containing 'string'
sed '/.*string.*/{n;s/.*/replaced_line_after/;}' $file  ## replace line after line containing 'string'
sed "$(( $( wc -l < $HISTFILE ) -1 )),\$d" $HISTFILE  ## remove $HISTORY last line
sed '$d' $HISTFILE; sed -e ':t;N;$!bt; s/\(\n[^\n]*\)\{1\}$/\n     deleted:&/' $HISTFILE | tail; sed -i '$d' $HISTFILE  ## remove $HISTORY last line and show result
sed '$d' $file  ## delete last line from $file
sed '/pttrn/d' $file  ## delete all lines in $file that contain pattern: 'pttrn'
sed '2,$d' $file  ## delete all lines from line 2 from $file
sed '2,3 d' $file  ## delete line 2 and 3 from $file
sed 'ni insert this at line n of file' $file  ## insert string at line n
sed 's/$find/$replace/g' $file  ## replace $find with $replace in $file
sed '/$find/{n;s/.*/$replace/}' $file  ## find $find and replace next line with $replace
sed -n -e :a -e '1,2!{P;N;D;};N;ba' $file  ## remove last 2 lines from $file
sed '/comm/s/./#&/' $file  ## comment lines containing 'comm' (add #; add '## ': /## &/)
sed '/no_comm/s/^[ \t]*#\+ *//' $file  ## uncomment lines containing 'no_comm' (remove #)
sed -n '1,10p' $file  ## sed emulate head
sed -i.bak "/^${user}:/ s/^${user}:!/\1:/" /etc/shadow  ##
printf $s2ls | sed 's/./\0\n/g'  ## print each character of a string on a separate line (string to lines)
set -euo pipefail  ## exit on: -e command error, -u unset variable expansion error, -o pipefail
set -o errexit -o nounset -o pipefail  ## exit on: -e command error, -u unset variable expansion error, -o pipefail
setfont ter-v32n  ## set console font
setopt  ## print set zshell options
setopt interactive_comments  ## zsh threats string after '#' as comment (unsetopt disables)
setopt nomatch; printf '%s\n' $directory/*.{gz,xz,zst} | sed '/\*/d'  ## list gz, xz and zst files (sed removes reported nomatches)
setopt $option  ## set (enable) zshell option
unsetopt $option  ## unset (disable) zshell option
sha3-512sum * > $sha3-512sums  ##  compute sha3-512 checksums in current directory
sha3-512sum --check --quiet $sha3-512sums  ## read checksums from sha3-512sums and verify
showkey --ascii --scancodes --keycodes  ## examine codes sent by the keyboard
shred --iterations=3 --zero --remove=wipesync --verbose $file  ## overwrite 3 times with random data, zero content, deallocate and remove $file
shuf --input-range 0-100 --head-count 1  ## shuffle integers between 0 and 100 and show first (pseudorandom number generator)
min=0; max=9999; columns=8; digits=4; i=1; shuf -i $min-$max | while read number; do [[ $(( i % $columns )) -eq 0 ]] && printf "%0${digits}d\n" $number || printf "%0${digits}d  " $number; i=$(( $i + 1 )); done  ## otp random secret key from $digit
for i in {1..32}; do; printf '%s' "$ASCII" | cut --characters "$(shuf -i 1-95 -n 1)" --zero-terminated; done; echo  ## generate passstring from $ASCII
for i in {1..32}; do; printf '%s' "$ASCII" | fold -w 1 | shuf | tr -d '\n'; done; echo  ## generate passstring
simple-mtpfs --list-devices  ## list mountable mtp devices
simple-mtpfs -o allow_other --device 1 $HOME/dock/mobile  ## mount mtp device 1
echo 'string2sort' | grep -o . | sort | tr -d "\n"  ## sort chars in string
sort $HISTFILE | uniq --count | sort -k1,1nr -k2 >> history_freq  ## create history frequency list
sort -k 2,2nr  ## numeric reversed sort only on column 2, not to eol
sort < $file | sort -nr > $file_sort_freq  ## reverse numerical sort
sort < $file | uniq --unique > $file_uniq  ## unique lines
sort $file | uniq --count | sort -k 1,1nr -k 2 | sed 's/^ *[0-9]* //' > file_freq_sort  ## sort columns: k1 numeric reverse then k2
source $function_text_appearance; printf "$(FHX ffbf00)$(BHX 0040ff)%s${NOC}\n" "$text"  ## hexadecimal 24 bit color codes in printf (fore- & background)
split $file -b N  ## split $file into files with N bytes
split $file -l N  ## split $file into files with N lines
split $file -n N  ## split $file into N files
sqlitebrowser $XDG_DATA_HOME/qutebrowser/history.sqlite  ## view qb history
sqlite3 -header -separator " " $XDG_DATA_HOME/qutebrowser/history.sqlite "select * from History;" | fzf --header-lines=1  ## fzf qb history
ssh-keygen -t ed25519-sk -C $key_id -f $key_file  ## generate openssh key
ssh-keygen -R 192.168.0.195  ## remove cached key for ip on the local machine
ssh-keyscan -t ecdsa 192.168.x.y >> $HOME/.ssh/known_hosts  ## update ecdsa key for ip on local machine
stat -c %A $file  ## display file access rights in human readable format
stat -c %a $file  ## display file access rights in octal format
stat [--terse] $file  ## [terse] display file or file system status
stty -a  ## print all terminal line settings (human readable)
stty -g  ## print all tty settings (stty readable)
stty $(head -n 1 $XDG_CONFIG_HOME/tty/default)  ## (re)set default tty settings
ts="$(now)"; stty_bu="$XDG_CONFIG_HOME/tty/"$ts"_sttyrc"; stty --save > $stty_bu && stty -all >> $stty_bu  ## backup terminal characteristics
sudo -k  ## (--reset timestamp) invalidate user cached credentials
sudo -l  ## (--list) list user privileges
sudo -v  ## (--validate) validate user cached credentials
sudo -n echo >/dev/null 2>&1; echo $?  ## print credential cache status (1 no 0 cache)
swaymsg -t get_outputs  ## list current sway outputs
swaymsg -t get_tree | jq '.. | select(.type?) | select(.focused==true) | .pid'  ## currently active terminal pid
swaymsg -t get_tree | jq -r '.nodes[].nodes[] | select(.type=="workspace").name'  ## list sway workspaces
swaymsg -t get_tree | jq -r '.nodes[].nodes[].nodes[] | select(.type=="con").name'  ## list sway containers
swaymsg -t get_tree | jq -r '.nodes[].nodes[].floating_nodes[].name'  ## list sway floating containers
swaymsg -t get_tree | jq -r 'recurse(.nodes[], .floating_nodes[]) | select(.shell) | "\(.id) \(.pid) \(.app_id // .window_properties.class) \(.name)"' | fzf -m | cut -d ' ' -f 1 | xargs -I {} swaymsg '[con_id={}]' kill  ## kill sway nodes (windows / frames) with fzf
swaymsg -t get_tree | jq -r 'recurse(.nodes[], .floating_nodes[]) | select(.shell) | "\(.id) \(.pid) \(.app_id // .window_properties.class) \(.name)"' | fzf | cut -d ' ' -f 1 | xargs -I {} swaymsg '[con_id={}]' focus  ## focus sway node (window / frame) with fzf
swaymsg -t get_tree | jq -r 'recurse(.nodes[], .floating_nodes[]) | select(.shell) | "\(.id) \(.pid) \(.app_id // .window_properties.class) \(.name)"' | grep float | cut -d ' ' -f 1 | xargs -I {} swaymsg '[con_id={}]' kill  ## kill all nodes whose name containing 'float'
ts=$(dtx); syncr $HOME/dock/transfer/x1c/home/oxo --delete --links --log-file=$XDG_LOGS_HOME/syncr/$ts | tee -a $XDG_LOGS_HOME/syncr/$ts  ## syncr backup with logging
echo '1' | sudo tee /proc/sys/kernel/sysrq  ## # obtain full sysrq priviledges
sysrq reisub  ## reboot
sysrq reisuo  ## shutdown
systemctl --failed  ## list failed units
systemctl list-units  ## list all units in memory
systemctl list-unit-files  ## list available unit files
systemctl start sshd.service  ## start sshd service (restart, stop)
systemctl --user start emacs.service  ## start service in user space
systemctl status $pttrn_pid  ## runtime status for unit with $pttrn or $pid
systemctl --user --now start pipewire pipewire-pulse wireplumber  ## start pipewire audio server and wireplumber session manager
systemd-analyze  ## analyze and debug system boot-up performance
systemd-analyze blame  ## how long it took to start each unit (process)
tail -f /var/log/{messages,kernel,dmesg,syslog}  ## TODO decription
tail -n 2 $file  ## print $file last 2 lines
tail -n +2 $file  ## print $file from line 2 (skip first line)
tac $file  ## concatenate and print file lines in reverse
tar -cv[j/z]f $archive.tar -C $subdir $files  ## create tar archive [bzip2/gzip compression (optional)] files in archive relative to $subdir
tar -tvf $archive.tar  ## print contents of tar archive
tar -cv[j/z/J]f $archive.tar $files  ## create tar archive [bzip2/gzip/xz compression (optional)]
tar -xv[j/z/J]f $archive.tar  ## extract tar archive [bzip2/gzip/xz compression (optional)]
tar -xv[j/z/J]f $archive.tar $path/single.file  ## extract single.file from tar archive [bzip2/gzip/xz compression (optional)]
tar -xv[j/z/J]f $archive.tar -O $file-in-tar  ## extract $file-in-tar to stdout
tar -rvf $archive.tar $file-to-append  ## append file to existing archive
tee --append $file1 $file2  ## append stdout to multiple files
test "$var"  ## check if $var is defined / non-null
[ "$var" ]  ## alias for: 'test "$var"'
[[ $var ]]  ## extended version of [ operator; with additional string, assignment and arithmetic operations and improved functionality, readability and performance
tmux attach-session -t 0  ## TODO decription
tmux show-options -g  ## TODO decription
touch --date=2000/01/01 $file  ## create file in time
tput reset  ## reinitialize terminal state
erase_line() {printf "\r"; tput el}  ## remove / delete line
printf '%s' "$l2s" | tr -d '\n'  ## remove newlines (lines to string)
wl-paste -n | tr -d '[:blank:]\t\r\n' | wl-copy -o -n  ## remove all whitespace from clipboard content and re-copy
tr --squeeze-repeats ' ' < $double_spaced_file > $single_spaced_file  ## remove double spaces
tr --delete --complement "[:alnum:]" < /dev/random | head -c 32  ## translate random stream in 32 alnum (alphanumeric) character class characters (generate passstring)
tr --delete --complement "[:alnum:]"'~!@#$%^&*()-=[];\,./_+{}:|<>?' < /dev/urandom | fold -w 32 | head -n 16 | fzf --height=17 --prompt=' select passstring: ' | awk '{print $2}' | wl-copy -o -n  ## generate, fzf select and copy one of 16 typable passstrings
trap "tput cnorm; return 1" SIGINT; while true; do tput civis; echo; figlet -f banner3 $(date +'%H%M%S'); sleep 1; for i in {1..8}; do tput el; tput cuu1; done; done  ## figlet clock (screencast)
fallocate -l 5M file  ## create file 5M size
truncate -s 5M file  ## create file 5M size
tree -n --charset=unicode  ## depth indented file listing
type -a $command  ## command interpretation (build-in or external); -a also prints all occurences in path
umount --lazy $mountpoint  ## umount busy targets (mountpoints)
uname --all  ## print system information
c /etc/os-release  ## systemd operating system identification data and information about the distribution
hostnamectl status  ## hostname operating system and related settings (i.e. firmware)
uniq --repeated  ## only print duplicate lines
unlink $link_name  ## remove $link_name (i.e. symlink)
unset varfun  ## unset value and attribute of variable or function varfun
unsetvar=  ## set variable unsetvar to '' (empty)
uptime  ## uptime since boot
< /proc/uptime | awk '{print $1}'  ## uptime in seconds
usermod -a -G $group $user  ## add user to group
printf "${var1:-$default}"  ## print default variable value if var1 is unset or null
printf "${var1:=$default}"  ## printf and set default variable value if var1 is unset or null
vim "+call cursor(line('$') - 1, 1)" "$HISTFILE"  ## open history in vim on previous command
vim "+call cursor(line('$') - 1, 1)" "$HISTFILE"; sed -i "/$(wl-paste)/d" "$HISTFILE"; wl-copy --clear  ## remove lines with selected pattern [dd ZZ] from history
vlock --all  ## console lock all sessions
env TERM=xterm watch --differences --no-title --interval 1 lsblk --ascii --tree -o name,uuid,fstype,path,size,fsuse%,fsused,label,mountpoint  ## watch lsblk w/ inverted text
watch --differences --no-title --interval 1 $command  ## default watch command
wc -l < $file  ## print number of lines in $file (< no filename)
wev -f wl_keyboard  ## show wayland keyboard events; keyID keynames
wf-recorder --audio --codec libx264 --file $video.mp4  ## recording video with wf-recorder
wget https://file.location -c -O file.location.txt_part  ## resume downloading file.location to file.location.txt_part
whatis $man_page_name  ## man page descriptions
which -a $command  ## show path of all $command (from $PATH)
optstring=":i:h"; while getopts $optstring opt; do; case $opt in i) var="${OPTARG}";; h) echo help_text;; \?) echo 'no opt';; :) echo 'hlp txt';; esac; done  ## command options (-i arg or -h)
while IFS= read -r pkg; do ls /var/cache/pacman/pkg | grep ^"$pkg"; done <<< "$(pacman -Qm | awk '{print $1}')"  ## which package from Qm is in /v/c/p/p
while read -r -u $fd l; do $commands; done {fd}< $file  ## read file line by line into l (with stdin redirection)
while read l; do $commands; done < $file  ## read file line by line into l
whois -B 46.166.142.215  ## whois own public ip
wl-paste >> $XDG_DATA_HOME/c/web/bookmark_urls  ## add to bookmark_urls (qb y m)
wl-paste | grep -Eo '[0-9]' | tail -n 4 | tr -d '[:blank:]\t\r\n'  ## last four digits from multiline string
wl-paste --no-newline | tr --delete '[:blank:]\t\r\n' | wl-copy --trim-newline --paste-once  ## selection without whitespace to clipboard
wl-paste | sed -n '1p' | sed 's/[^0-9]//g' | cut -c 1-4  ## first four digits from multiline string
wf-recorder -g "$(slurp)"  ## video capture part of screen
wf-recorder --audio --file=recording_with_audio.avi  ## capture whole screen with audio
read -er -p 'SSID?' ssid | wpa_passphrase "$ssid" > "$SSID".wifi  ## generate wl access file
wpa_passphrase $ssid $passphrase > ssid.wifi  ## create network section of wpa_supplicant configuration
wpa_supplicant -B -i $wlp -c ~/keys/wl/ssid.wifi  ## wireless connect via interface $wlp to ssid.wifi
xargs --no-run-if-empty --verbose command  ## run command with stdin as argument, no-run if empty
xxd -groupsize 1 <<< $ASCII  ## hexdump space separated bytes of $ASCII
xxd -bits <<< $ASCII  ## bitdump of $ASCII
xxd -plain $infile $outfile  ## write plain hexdump of $infile to $outfile
xxd -plain -revert $infile $outfile  ## reverse plain hexdump
xz -d  ## decompress .xz file
xz -l  ## list .xz file
xz -z  ## compress .xz file
yay --gendb  ## generate developement package database
yay -Qqm | yay -Gd -   ## download package builds from installed aur packages
yay -P  ## show (is a yay specific [no pacman] option)
yay -Ps && yay --show -w && yay -Syu && yay -Rns $(yay -Qtdq) && paccache -rv  ## system package stats, news, upgrade and cleanup
yay -P --news  ## show news newer than the build date of all native packages
yay --show -w -w  ## aurch linux (last year?) news archives [Arch Linux - News](https://archlinux.org/news/)
yay -Q  ## query package database; display installed packages with version (Q=Qd+Qe=Qm+Qn)
yay -Qc $file	## query package database; display changelog $file  ## TODO decription
yay -Qd  ## (--deps) query package database; display packages installed as dependencies
yay -Qdt  ## query package database; display unrequired deps
yay -Qe  ## (--explicit) query package database; display explicitly installed packages
yay -Qent  ## query package database; display explicitly installed (no dependencies), not required packages that are in the package database
yay -Qg $group  ## query package database; display packages that are member of $group
yay -Qi $package  ## query package database; display package infoos that are member of $groupcman
yay -Qk $package  ## query package database; display number of total and missing files, check that all files of the package are present on the system
yay -Ql $package  ## query package database; display package file list (prepended by $package)
yay -Qlq $package  ## query package database; display package file list (raw)
yay -Qm  ## (--foreign) query package database; display packages that are not in the sync database (aur packages)
yay -Qmq  ## (--foreign) query package database; display packages that are not in the sync database no version
yay -Qn  ## (--native) query package database; display packages that are in the sync database
yay -Qnq  ## (--native) query package database; display packages that are in the sync database no version
yay -Qnq | yay -S -  ## reinstall native packages
yay -Qo $file  ## query package database; display which package owns $file
yay -Qs  ## search locally for matching strings
yay -Qq  ## query package database; display installed packages (raw)
yay -R $package || $group  ## remove [package] OR [group]
yay -Rns $package  ## remove [package] including not required and not explicitly installed dependencies, no pacsave
yay -Qdtq | yay -Rnsc -   ## remove unrequired dependencies including not required and not explicitly installed dependencies, no pacsave
yay -Yc  ## same (?) as: yay -Qtdq | yay -Rnsc -; remove unrequired dependencies including not required and not explicitly installed dependencies, no pacsave
yay -S $package  ## synchronize package; download and install
yay -S --dbpath $alt_repo_db --cachedir $alt_repo_cache $package  ## synchronize package; download and install, using alternative repo (database file and cache dir)
yay -S --print $package  ## print native package location URI (file:// if locally available)
yay -Sau ## update only AUR packages
yay -Sc $package  ## remove all cached packages that are currently not installed (more agressive than paccache)
yay -Scc $package  ## remove all cached packages (far more agressive than paccache, will prevent downgrading or reinstalling without downloading)
yay -Sii $package  ## extended package info; reverse dependencies; package required by
yay -Sw $package  ## synchronize package only download, not install
yay -Syu --devel --timeupdate  ## update, also check AUR developement packages (git), timeupdate (instead of version number)
yay -Tv  ## check dependencies; show file paths
yay -U $package  ## remove then upgrade or add package
ykman otp static --no-enter --keyboard-layout US 2 'string'  ## assign string to yk slot 2
yt-dlp --format-sort res:480 $(wl-paste)  ## download video with maximal 480 vertical pixel resolution (SD)
yt-dlp --extract-audio $(wl-paste)  ## download audio only
zbarcam --oneshot --raw /dev/video4 | wl-copy -o -n  ## read qr from video4
zsh --no-rcs  ## zsh terminal without run command script
chmod 0000  ## ---------- 	ugo -	no permissions
chmod 0111  ## ---x--x--x 	ugo x				execute
chmod 0222  ## --w--w--w- 	ugo w			write
chmod 0333  ## --wx-wx-wx 	ugo wx			write	execute
chmod 0444  ## -r--r--r-- 	ugo r	read
chmod 0555  ## -r-xr-xr-x 	ugo xr	read			execute
chmod 0666  ## -rw-rw-rw- 	ugo	rw	read	write
chmod 0777  ## -rwxrwxrwx 	ugo	rwx	read	write	execute
chmod 0700  ## -rwx------ 	u	rwx	g	-	o	-
chmod 0740  ## -rwxr----- 	u	rwx	g	r	o	-
chmod 0770  ## -rwxrwx--- 	u	rwx	g	rwx	o	-
case $expr in pattern1) echo 1 ;; ptrn2) echo 2 ;; *) echo 3 ;; esac  ## case statement basic structure
if [[ $i -eq 0 ]]; then; echo 0; elif [[ $i -lt 0 ]]; then; echo neg; else; echo pos; fi  ## if elif else statement basic structure
for i in 1 2 3; do; echo $i; done  ## for loop basic structure; hardcoded list values
for (( i=$in; i<=$ix; i++ )); do echo $i; done  ## for loop alternative mathematic structure; variable list values (in to ix step i++)
for i in $space_sep_string; do; echo $i; done  ## for loop through space separated string
select option in 'a' 'b' 'c'; do echo "selection: $option"; break; done  ## select basic structure
while IFS='=' read -r key value; do; config-array[$key]=$value; done < ./config-file  ## read key value pairs from file into array
while read line; do; echo $line; done <<< "$variable"  ## while loop through lines in $variable (herestring)
while [[ $i -lt 3 ]]; do echo $i; ((i+=1)); done  ## while loop basic structure upcount, increase $i by one
while [[ $i -lt 3 ]]; do echo $i; ((i++)); done  ## while loop basic structure upcount, increase $i by one
until [[ $i -gt 3 ]]; do echo $i; ((i+=1)); done  ## until loop basic structure upcount, increase $i by one
while [[ $i -gt -3 ]]; do echo $i; ((i--)); done  ## while loop basic structure downcount, decrease $i by one
until [[ $i -lt -3 ]]; do echo $i; ((i--)); done  ## until loop basic structure downcount, decrease $i by one
while true do; echo; done  ## infinite loop
break  ## exit from an enclosing loop
continue  ## resume next iteration of enclosing loop
[[ "$var" =~ extended-regexp ]]  ## test with extended regular expression operator
reset  ## clear + reset internal terminal state + 1sec delay
tput reset  ## same as reset but without 1sec delay
stty sane  ## don't clear screen but reset some terminal options
echo -e "\033c"  ## same as tput reset but hardcoded escape seq
printf "\033c"  ## same as tput reset but hardcoded escape seq
setterm -reset  ## same as tput reset, setterm has more user friendly commands
pea () { declare -n __p="$1"; for k in "${!__p[@]}"; do printf "%s=%s\n" "$k" "${__p[$k]}"; done }  ## print entire array: pea array
echo general quotation rule  ## quote if $var can be empty (null) or contain whitespace or punct chartacters (wildcards)
$(command)  ## command substitution; gets the result of command
$(( expression ))  ## arithmetic expansion; gets the result of $expression
<(list)  ## process substitution; process list is run async and writing to the file will provide input for list
>(list)  ## process substitution; process list is run async and the file passed as an argument should be read to obtain the output of list
$command <<- EOF >> $file\n multi\nline\ntext\nmlt\nEOF\n  ## input read until EOF (<< heredoc) to command, strip leading tabs from mlt (-), EOF can be any unique limit string
